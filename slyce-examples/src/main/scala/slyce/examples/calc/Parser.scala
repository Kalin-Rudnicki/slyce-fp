// !!! DO NOT MODIFY !!!
// File was automatically generated by slyce v1.1.0

package slyce.examples.calc

// format: off

import scala.annotation.tailrec

import klib.Implicits._
import klib.fp.types._
import klib.utils._

import slyce.core._
import slyce.parse._

object Parser {
  
  sealed abstract class Tok(val tokName: String) extends Token
  object Tok {
    final case class addOp(text: String, span: Span.Highlight) extends Tok("addOp") with NonTerminal.Expr1.Operator
    final case class float(text: String, span: Span.Highlight) extends Tok("float") with NonTerminal.Expr1.Operand
    final case class int(text: String, span: Span.Highlight) extends Tok("int") with NonTerminal.Expr1.Operand
    final case class multOp(text: String, span: Span.Highlight) extends Tok("multOp") with NonTerminal.Expr1.Operator
    final case class powOp(text: String, span: Span.Highlight) extends Tok("powOp") with NonTerminal.Expr1.Operator
    final case class variable(text: String, span: Span.Highlight) extends Tok("variable") with NonTerminal.Expr1.Operand
    
    final case class `(`(text: String, span: Span.Highlight) extends Tok(""""("""")
    final case class `)`(text: String, span: Span.Highlight) extends Tok("""")"""")
    final case class `;`(text: String, span: Span.Highlight) extends Tok("""";"""")
    final case class `=`(text: String, span: Span.Highlight) extends Tok(""""="""")
    final case class `~`(text: String, span: Span.Highlight) extends Tok(""""~"""")
    
    def findRawTerminal(text: String, span: Span.Highlight): Attempt[Tok] =
      text match {
        case "(" => Tok.`(`(text, span).pure[Attempt]
        case ")" => Tok.`)`(text, span).pure[Attempt]
        case ";" => Tok.`;`(text, span).pure[Attempt]
        case "=" => Tok.`=`(text, span).pure[Attempt]
        case "~" => Tok.`~`(text, span).pure[Attempt]
        case _ => Dead(Marked(s"Invalid raw-terminal : ${text.unesc}", span) :: Nil)
      }
  }
  
  type NtRoot = NonTerminal.Lines
  sealed trait NonTerminal
  object NonTerminal {
    type Lines = LinesHead
    type Expr = Expr1
    
    final case class Assign(
      _0: Tok.variable,
      _1: Tok.`=`,
      _2: NonTerminal.Expr1,
    ) extends NonTerminal
    
    sealed trait Expr1 extends NonTerminal {
      
      def toExpr: Expression[Expr1.Operand, Expr1.Operator] = {
        def toExpr1(expr: Expr1): Expression[Expr1.Operand, Expr1.Operator] =
          expr match {
            case Expr1._1(left, op, right) =>
              Expression[Expr1.Operand, Expr1.Operator](
                toExpr1(left),
                op,
                toExpr2(right),
              )
            case Expr1._2(child) =>
              toExpr2(child)
          }
        
        def toExpr2(expr: Expr2): Expression[Expr1.Operand, Expr1.Operator] =
          expr match {
            case Expr2._1(left, op, right) =>
              Expression[Expr1.Operand, Expr1.Operator](
                toExpr2(left),
                op,
                toExpr3(right),
              )
            case Expr2._2(child) =>
              toExpr3(child)
          }
        
        def toExpr3(expr: Expr3): Expression[Expr1.Operand, Expr1.Operator] =
          expr match {
            case Expr3._1(left, op, right) =>
              Expression[Expr1.Operand, Expr1.Operator](
                toExpr4(left),
                op,
                toExpr3(right),
              )
            case Expr3._2(child) =>
              toExpr4(child)
          }
        
        def toExpr4(expr: Expr4): Expression[Expr1.Operand, Expr1.Operator] =
          expr match {
            case expr: Expr4._1 =>
              Expression[Expr1.Operand, Expr1.Operator](expr._0)
            case expr: Expr4._2 =>
              Expression[Expr1.Operand, Expr1.Operator](expr._0)
            case expr: Expr4._3 =>
              Expression[Expr1.Operand, Expr1.Operator](expr._0)
            case expr: Expr4._4 =>
              toExpr1(expr._1)
          }
        
        toExpr1(this)
      }
      
    }
    object Expr1 {
      sealed trait Operator
      sealed trait Operand
      
      final case class _1(
        _0: NonTerminal.Expr1,
        _1: Tok.addOp,
        _2: NonTerminal.Expr2,
      ) extends Expr1
      final case class _2(
        _0: NonTerminal.Expr2,
      ) extends Expr1
    }
    
    sealed trait Expr2 extends NonTerminal
    object Expr2 {
      final case class _1(
        _0: NonTerminal.Expr2,
        _1: Tok.multOp,
        _2: NonTerminal.Expr3,
      ) extends Expr2
      final case class _2(
        _0: NonTerminal.Expr3,
      ) extends Expr2
    }
    
    sealed trait Expr3 extends NonTerminal
    object Expr3 {
      final case class _1(
        _0: NonTerminal.Expr4,
        _1: Tok.powOp,
        _2: NonTerminal.Expr3,
      ) extends Expr3
      final case class _2(
        _0: NonTerminal.Expr4,
      ) extends Expr3
    }
    
    sealed trait Expr4 extends NonTerminal
    object Expr4 {
      final case class _1(
        _0: Tok.variable,
      ) extends Expr4
      final case class _2(
        _0: Tok.int,
      ) extends Expr4
      final case class _3(
        _0: Tok.float,
      ) extends Expr4
      final case class _4(
        _0: Tok.`(`,
        _1: NonTerminal.Expr1,
        _2: Tok.`)`,
      ) extends Expr4
    }
    
    sealed trait Line extends NonTerminal
    object Line {
      final case class _1(
        _0: NonTerminal.Assign,
      ) extends Line
      final case class _2(
        _0: NonTerminal.Expr1,
        _1: NonTerminal.`Opt_~`,
      ) extends Line
    }
    
    final case class LinesHead(
      _0: NonTerminal.Line,
      _1: Tok.`;`,
      _2: NonTerminal.LinesTail,
    ) extends NonTerminal {
      
      def toNonEmptyList: NonEmptyList[LinesHead.LiftType] = {
        @tailrec
        def loop(queue: LinesTail, stack: List[LinesHead.LiftType]): List[LinesHead.LiftType] =
          queue match {
            case head: LinesTail._1 => loop(head._2, head._0 :: stack)
            case _: LinesTail._2.type => stack.reverse
          }
        
        NonEmptyList[LinesHead.LiftType](this._0, loop(this._2, Nil))
      }
      
    }
    object LinesHead {
      type LiftType = NonTerminal.Line
    }
    
    sealed trait LinesTail extends NonTerminal
    object LinesTail {
      final case class _1(
        _0: NonTerminal.Line,
        _1: Tok.`;`,
        _2: NonTerminal.LinesTail,
      ) extends LinesTail
      case object _2 extends LinesTail
    }
    
    sealed trait `Opt_~` extends NonTerminal {
      
      def toMaybe: Maybe[`Opt_~`.LiftType] =
        this match {
          case `Opt_~`._1(some) => some.some
          case `Opt_~`._2 => None
        }
      
    }
    object `Opt_~` {
      type LiftType = Tok.`~`
      
      final case class _1(
        _0: Tok.`~`,
      ) extends `Opt_~`
      case object _2 extends `Opt_~`
    }
    
  }
  
  lazy val parser: Parser[Tok, NonTerminal, NtRoot] =
    Parser[Tok, NonTerminal, NtRoot](
      Lexer[Tok] {
        var s5: Lexer.State[Tok] = null
        var s0: Lexer.State[Tok] = null
        var s1: Lexer.State[Tok] = null
        var s2: Lexer.State[Tok] = null
        var s3: Lexer.State[Tok] = null
        var s4: Lexer.State[Tok] = null
        var s6: Lexer.State[Tok] = null
        var s7: Lexer.State[Tok] = null
        var s8: Lexer.State[Tok] = null
        var s9: Lexer.State[Tok] = null
        var s10: Lexer.State[Tok] = null
        
        s5 =
          Lexer.State[Tok](
            5,
            char => {
              val int = char.toInt
              
              if (int == 42) // '*'
                s4.some
              else if (int == 47) // '/'
                s4.some
              else if (int >= 97 && int <= 122) // 'a'-'z'
                s1.some
              else if (int >= 48 && int <= 57) // '0'-'9'
                s8.some
              else if (int >= 40 && int <= 41) // '('-')'
                s9.some
              else if (int == 59) // ';'
                s9.some
              else if (int == 61) // '='
                s9.some
              else if (int == 126) // '~'
                s9.some
              else if (int == 43) // '+'
                s6.some
              else if (int >= 9 && int <= 10) // '\t'-'\n'
                s7.some
              else if (int == 32) // ' '
                s7.some
              else if (int == 94) // '^'
                s2.some
              else if (int == 45) // '-'
                s10.some
              else
                None
            },
            None,
          )
        
        s0 =
          Lexer.State[Tok](
            0,
            char => {
              val int = char.toInt
              
              if (int >= 48 && int <= 57) // '0'-'9'
                s0.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.float(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s1 =
          Lexer.State[Tok](
            1,
            char => {
              val int = char.toInt
              
              if (int >= 48 && int <= 57) // '0'-'9'
                s1.some
              else if (int >= 65 && int <= 90) // 'A'-'Z'
                s1.some
              else if (int == 95) // '_'
                s1.some
              else if (int >= 97 && int <= 122) // 'a'-'z'
                s1.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.variable(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s2 =
          Lexer.State[Tok](
            2,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.powOp(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s3 =
          Lexer.State[Tok](
            3,
            char => {
              val int = char.toInt
              
              if (int >= 48 && int <= 57) // '0'-'9'
                s0.some
              else
                None
            },
            None,
          )
        
        s4 =
          Lexer.State[Tok](
            4,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.multOp(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s6 =
          Lexer.State[Tok](
            6,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.addOp(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s7 =
          Lexer.State[Tok](
            7,
            _ => None,
            Lexer.Yields[Tok](
              List(
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s8 =
          Lexer.State[Tok](
            8,
            char => {
              val int = char.toInt
              
              if (int == 46) // '.'
                s3.some
              else if (int >= 48 && int <= 57) // '0'-'9'
                s8.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.int(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s9 =
          Lexer.State[Tok](
            9,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.findRawTerminal,
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s10 =
          Lexer.State[Tok](
            10,
            char => {
              val int = char.toInt
              
              if (int >= 48 && int <= 57) // '0'-'9'
                s8.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.addOp(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        
        s5
      },
      Grammar[Tok, NonTerminal, NtRoot] {
        var s0: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s1: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s2: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s3: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s4: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s5: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s6: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s7: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s8: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s9: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s10: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s11: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s12: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s13: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s14: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s15: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s16: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s17: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s18: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s19: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s20: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s21: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s22: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s23: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s24: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s25: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s26: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s27: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s28: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s29: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s30: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s31: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s32: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s33: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s34: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s35: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s36: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s37: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s38: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s39: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s40: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s41: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s42: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s43: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s44: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s45: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s46: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s47: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s48: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s49: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s50: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s51: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s52: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s53: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s54: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s55: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s56: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s57: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s58: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s59: Grammar.State[Tok, NonTerminal, NtRoot] = null
        
        s0 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            0,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.powOp =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.Expr1), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.multOp =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.Expr1), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.Expr1), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.Expr1), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s1 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            1,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.multOp =>
                      (
                        s10,
                        (tok.left, s1) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr2), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr1._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr2), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr1._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`~` =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr2), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr1._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s2 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            2,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.int =>
                      (
                        s59,
                        (tok.left, s2) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.float =>
                      (
                        s15,
                        (tok.left, s2) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.variable =>
                      (
                        s13,
                        (tok.left, s2) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s38,
                        (tok.left, s2) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Expr3 =>
                s21
              case _: NonTerminal.Expr2 =>
                s40
              case _: NonTerminal.Expr4 =>
                s30
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s3 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            3,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr1), _) :: (Left(_2: Tok.`=`), _) :: (Left(_1: Tok.variable), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Assign(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      (
                        s2,
                        (tok.left, s3) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s4 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            4,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.powOp =>
                      stack match {
                        case (Left(_1: Tok.variable), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.multOp =>
                      stack match {
                        case (Left(_1: Tok.variable), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.variable), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Left(_1: Tok.variable), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s5 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            5,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s0,
                        (tok.left, s5) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.addOp =>
                      (
                        s57,
                        (tok.left, s5) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s6 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            6,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.multOp =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr3), _) :: (Left(_2: Tok.powOp), _) :: (Right(_1: NonTerminal.Expr4), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr3._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr3), _) :: (Left(_2: Tok.powOp), _) :: (Right(_1: NonTerminal.Expr4), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr3._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr3), _) :: (Left(_2: Tok.powOp), _) :: (Right(_1: NonTerminal.Expr4), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr3._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s7 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            7,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.int =>
                      (
                        s59,
                        (tok.left, s7) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.float =>
                      (
                        s15,
                        (tok.left, s7) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.variable =>
                      (
                        s13,
                        (tok.left, s7) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s38,
                        (tok.left, s7) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Expr3 =>
                s41
              case _: NonTerminal.Expr4 =>
                s30
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s8 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            8,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.multOp =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr3), _) :: (Left(_2: Tok.powOp), _) :: (Right(_1: NonTerminal.Expr4), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr3._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr3), _) :: (Left(_2: Tok.powOp), _) :: (Right(_1: NonTerminal.Expr4), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr3._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr3), _) :: (Left(_2: Tok.powOp), _) :: (Right(_1: NonTerminal.Expr4), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr3._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`~` =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr3), _) :: (Left(_2: Tok.powOp), _) :: (Right(_1: NonTerminal.Expr4), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr3._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s9 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            9,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      (
                        s39,
                        (tok.left, s9) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s10 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            10,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.int =>
                      (
                        s58,
                        (tok.left, s10) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.float =>
                      (
                        s31,
                        (tok.left, s10) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.variable =>
                      (
                        s23,
                        (tok.left, s10) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s53,
                        (tok.left, s10) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Expr3 =>
                s32
              case _: NonTerminal.Expr4 =>
                s29
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s11 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            11,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.int =>
                      (
                        s17,
                        (tok.left, s11) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.float =>
                      (
                        s48,
                        (tok.left, s11) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.variable =>
                      (
                        s4,
                        (tok.left, s11) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s37,
                        (tok.left, s11) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Expr3 =>
                s6
              case _: NonTerminal.Expr4 =>
                s42
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s12 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            12,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Assign), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Line._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s13 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            13,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.powOp =>
                      stack match {
                        case (Left(_1: Tok.variable), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.multOp =>
                      stack match {
                        case (Left(_1: Tok.variable), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.variable), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Left(_1: Tok.variable), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s14 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            14,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.`Opt_~`._2
                      val to = s14.onNt(nt) 
                      (
                        to,
                        (nt.right, s14) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.addOp =>
                      (
                        s45,
                        (tok.left, s14) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`~` =>
                      (
                        s18,
                        (tok.left, s14) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.`Opt_~` =>
                s24
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s15 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            15,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.powOp =>
                      stack match {
                        case (Left(_1: Tok.float), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.multOp =>
                      stack match {
                        case (Left(_1: Tok.float), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.float), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Left(_1: Tok.float), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s16 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            16,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.int =>
                      (
                        s58,
                        (tok.left, s16) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.float =>
                      (
                        s31,
                        (tok.left, s16) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.variable =>
                      (
                        s23,
                        (tok.left, s16) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s53,
                        (tok.left, s16) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Expr3 =>
                s8
              case _: NonTerminal.Expr4 =>
                s29
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s17 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            17,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.powOp =>
                      stack match {
                        case (Left(_1: Tok.int), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.multOp =>
                      stack match {
                        case (Left(_1: Tok.int), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.int), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Left(_1: Tok.int), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s18 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            18,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.`~`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_~`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s19 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            19,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.int =>
                      (
                        s59,
                        (tok.left, s19) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.float =>
                      (
                        s15,
                        (tok.left, s19) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.variable =>
                      (
                        s13,
                        (tok.left, s19) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s38,
                        (tok.left, s19) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Expr3 =>
                s55
              case _: NonTerminal.Expr4 =>
                s30
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s20 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            20,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok =>
                      None
                  }
                case None =>
                  stack match {
                    case (Right(ntRoot: NtRoot), _) :: Nil =>
                      ntRoot.right.some
                    case _ =>
                      None
                  }
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s21 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            21,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.multOp =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr3), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr2._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr3), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr2._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr3), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr2._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s22 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            22,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok =>
                      None
                  }
                case None =>
                  stack match {
                    case (Right(_3: NonTerminal.LinesTail), _) :: (Left(_2: Tok.`;`), _) :: (Right(_1: NonTerminal.Line), poppedState) :: stack =>
                      val nt: NonTerminal = NonTerminal.LinesTail._1(_1, _2, _3)
                      val to = poppedState.onNt(nt)
                      (
                        to,
                        (nt.right, poppedState) :: stack,
                        None,
                      ).left.some
                    case _ =>
                      None
                  }
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s23 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            23,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.multOp =>
                      stack match {
                        case (Left(_1: Tok.variable), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.powOp =>
                      stack match {
                        case (Left(_1: Tok.variable), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`~` =>
                      stack match {
                        case (Left(_1: Tok.variable), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Left(_1: Tok.variable), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.variable), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s24 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            24,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_~`), _) :: (Right(_1: NonTerminal.Expr1), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Line._2(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s25 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            25,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.multOp =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr3), _) :: (Left(_2: Tok.multOp), _) :: (Right(_1: NonTerminal.Expr2), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr2._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr3), _) :: (Left(_2: Tok.multOp), _) :: (Right(_1: NonTerminal.Expr2), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr2._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr3), _) :: (Left(_2: Tok.multOp), _) :: (Right(_1: NonTerminal.Expr2), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr2._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s26 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            26,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.int =>
                      (
                        s17,
                        (tok.left, s26) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.float =>
                      (
                        s48,
                        (tok.left, s26) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.variable =>
                      (
                        s4,
                        (tok.left, s26) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s37,
                        (tok.left, s26) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Expr3 =>
                s25
              case _: NonTerminal.Expr4 =>
                s42
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s27 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            27,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.multOp =>
                      (
                        s19,
                        (tok.left, s27) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr2), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr1._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr2), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr1._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s28 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            28,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.multOp =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.Expr1), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.powOp =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.Expr1), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`~` =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.Expr1), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.Expr1), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.Expr1), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s29 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            29,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.multOp =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr4), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr3._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.powOp =>
                      (
                        s16,
                        (tok.left, s29) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`~` =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr4), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr3._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr4), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr3._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr4), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr3._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s30 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            30,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.powOp =>
                      (
                        s7,
                        (tok.left, s30) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.multOp =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr4), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr3._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr4), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr3._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr4), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr3._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s31 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            31,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.multOp =>
                      stack match {
                        case (Left(_1: Tok.float), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.powOp =>
                      stack match {
                        case (Left(_1: Tok.float), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`~` =>
                      stack match {
                        case (Left(_1: Tok.float), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Left(_1: Tok.float), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.float), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s32 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            32,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.multOp =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr3), _) :: (Left(_2: Tok.multOp), _) :: (Right(_1: NonTerminal.Expr2), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr2._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr3), _) :: (Left(_2: Tok.multOp), _) :: (Right(_1: NonTerminal.Expr2), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr2._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr3), _) :: (Left(_2: Tok.multOp), _) :: (Right(_1: NonTerminal.Expr2), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr2._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`~` =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr3), _) :: (Left(_2: Tok.multOp), _) :: (Right(_1: NonTerminal.Expr2), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr2._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s33 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            33,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s34,
                        (tok.left, s33) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.addOp =>
                      (
                        s57,
                        (tok.left, s33) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s34 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            34,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.powOp =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.Expr1), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.multOp =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.Expr1), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.Expr1), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.Expr1), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s35 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            35,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.multOp =>
                      stack match {
                        case (Left(_1: Tok.variable), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.powOp =>
                      stack match {
                        case (Left(_1: Tok.variable), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`~` =>
                      stack match {
                        case (Left(_1: Tok.variable), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`=` =>
                      (
                        s50,
                        (tok.left, s35) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.addOp =>
                      stack match {
                        case (Left(_1: Tok.variable), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.variable), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s36 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            36,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.multOp =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr3), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr2._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr3), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr2._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr3), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr2._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`~` =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr3), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr2._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s37 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            37,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.int =>
                      (
                        s17,
                        (tok.left, s37) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.float =>
                      (
                        s48,
                        (tok.left, s37) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.variable =>
                      (
                        s4,
                        (tok.left, s37) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s37,
                        (tok.left, s37) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Expr3 =>
                s49
              case _: NonTerminal.Expr1 =>
                s33
              case _: NonTerminal.Expr2 =>
                s51
              case _: NonTerminal.Expr4 =>
                s42
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s38 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            38,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.int =>
                      (
                        s17,
                        (tok.left, s38) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.float =>
                      (
                        s48,
                        (tok.left, s38) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.variable =>
                      (
                        s4,
                        (tok.left, s38) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s37,
                        (tok.left, s38) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Expr3 =>
                s49
              case _: NonTerminal.Expr1 =>
                s5
              case _: NonTerminal.Expr2 =>
                s51
              case _: NonTerminal.Expr4 =>
                s42
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s39 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            39,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s53,
                        (tok.left, s39) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.int =>
                      (
                        s58,
                        (tok.left, s39) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.variable =>
                      (
                        s35,
                        (tok.left, s39) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.float =>
                      (
                        s31,
                        (tok.left, s39) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  val nt: NonTerminal = NonTerminal.LinesTail._2
                  val to = s39.onNt(nt) 
                  (
                    to,
                    (nt.right, s39) :: stack,
                    None,
                  ).left.some
              }
            },
            {
              case _: NonTerminal.Expr2 =>
                s1
              case _: NonTerminal.LinesTail =>
                s54
              case _: NonTerminal.Expr1 =>
                s14
              case _: NonTerminal.Expr3 =>
                s36
              case _: NonTerminal.Assign =>
                s12
              case _: NonTerminal.Expr4 =>
                s29
              case _: NonTerminal.Line =>
                s44
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s40 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            40,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.multOp =>
                      (
                        s19,
                        (tok.left, s40) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr2), _) :: (Left(_2: Tok.addOp), _) :: (Right(_1: NonTerminal.Expr1), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr1._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr2), _) :: (Left(_2: Tok.addOp), _) :: (Right(_1: NonTerminal.Expr1), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr1._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s41 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            41,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.multOp =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr3), _) :: (Left(_2: Tok.powOp), _) :: (Right(_1: NonTerminal.Expr4), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr3._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr3), _) :: (Left(_2: Tok.powOp), _) :: (Right(_1: NonTerminal.Expr4), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr3._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr3), _) :: (Left(_2: Tok.powOp), _) :: (Right(_1: NonTerminal.Expr4), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr3._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s42 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            42,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.powOp =>
                      (
                        s11,
                        (tok.left, s42) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.multOp =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr4), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr3._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr4), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr3._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr4), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr3._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s43 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            43,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s53,
                        (tok.left, s43) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.int =>
                      (
                        s58,
                        (tok.left, s43) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.variable =>
                      (
                        s35,
                        (tok.left, s43) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.float =>
                      (
                        s31,
                        (tok.left, s43) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  val nt: NonTerminal = NonTerminal.LinesTail._2
                  val to = s43.onNt(nt) 
                  (
                    to,
                    (nt.right, s43) :: stack,
                    None,
                  ).left.some
              }
            },
            {
              case _: NonTerminal.Expr2 =>
                s1
              case _: NonTerminal.LinesTail =>
                s22
              case _: NonTerminal.Expr1 =>
                s14
              case _: NonTerminal.Expr3 =>
                s36
              case _: NonTerminal.Assign =>
                s12
              case _: NonTerminal.Expr4 =>
                s29
              case _: NonTerminal.Line =>
                s44
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s44 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            44,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      (
                        s43,
                        (tok.left, s44) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s45 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            45,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.int =>
                      (
                        s58,
                        (tok.left, s45) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.float =>
                      (
                        s31,
                        (tok.left, s45) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.variable =>
                      (
                        s23,
                        (tok.left, s45) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s53,
                        (tok.left, s45) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Expr3 =>
                s36
              case _: NonTerminal.Expr2 =>
                s46
              case _: NonTerminal.Expr4 =>
                s29
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s46 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            46,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.multOp =>
                      (
                        s10,
                        (tok.left, s46) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr2), _) :: (Left(_2: Tok.addOp), _) :: (Right(_1: NonTerminal.Expr1), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr1._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr2), _) :: (Left(_2: Tok.addOp), _) :: (Right(_1: NonTerminal.Expr1), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr1._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`~` =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr2), _) :: (Left(_2: Tok.addOp), _) :: (Right(_1: NonTerminal.Expr1), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr1._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s47 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            47,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s28,
                        (tok.left, s47) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.addOp =>
                      (
                        s57,
                        (tok.left, s47) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s48 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            48,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.powOp =>
                      stack match {
                        case (Left(_1: Tok.float), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.multOp =>
                      stack match {
                        case (Left(_1: Tok.float), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.float), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Left(_1: Tok.float), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s49 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            49,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.multOp =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr3), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr2._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr3), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr2._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr3), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr2._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s50 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            50,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.int =>
                      (
                        s59,
                        (tok.left, s50) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.float =>
                      (
                        s15,
                        (tok.left, s50) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.variable =>
                      (
                        s13,
                        (tok.left, s50) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s38,
                        (tok.left, s50) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Expr3 =>
                s21
              case _: NonTerminal.Expr1 =>
                s3
              case _: NonTerminal.Expr2 =>
                s27
              case _: NonTerminal.Expr4 =>
                s30
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s51 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            51,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.multOp =>
                      (
                        s26,
                        (tok.left, s51) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr2), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr1._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Right(_1: NonTerminal.Expr2), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr1._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s52 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            52,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.int =>
                      (
                        s58,
                        (tok.left, s52) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.float =>
                      (
                        s31,
                        (tok.left, s52) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.variable =>
                      (
                        s35,
                        (tok.left, s52) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s53,
                        (tok.left, s52) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Expr2 =>
                s1
              case _: NonTerminal.Expr1 =>
                s14
              case _: NonTerminal.Expr3 =>
                s36
              case _: NonTerminal.Lines =>
                s20
              case _: NonTerminal.Assign =>
                s12
              case _: NonTerminal.Expr4 =>
                s29
              case _: NonTerminal.Line =>
                s9
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s53 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            53,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.int =>
                      (
                        s17,
                        (tok.left, s53) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.float =>
                      (
                        s48,
                        (tok.left, s53) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.variable =>
                      (
                        s4,
                        (tok.left, s53) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s37,
                        (tok.left, s53) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Expr3 =>
                s49
              case _: NonTerminal.Expr1 =>
                s47
              case _: NonTerminal.Expr2 =>
                s51
              case _: NonTerminal.Expr4 =>
                s42
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s54 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            54,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok =>
                      None
                  }
                case None =>
                  stack match {
                    case (Right(_3: NonTerminal.LinesTail), _) :: (Left(_2: Tok.`;`), _) :: (Right(_1: NonTerminal.Line), poppedState) :: stack =>
                      val nt: NonTerminal = NonTerminal.LinesHead(_1, _2, _3)
                      val to = poppedState.onNt(nt)
                      (
                        to,
                        (nt.right, poppedState) :: stack,
                        None,
                      ).left.some
                    case _ =>
                      None
                  }
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s55 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            55,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.multOp =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr3), _) :: (Left(_2: Tok.multOp), _) :: (Right(_1: NonTerminal.Expr2), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr2._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr3), _) :: (Left(_2: Tok.multOp), _) :: (Right(_1: NonTerminal.Expr2), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr2._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr3), _) :: (Left(_2: Tok.multOp), _) :: (Right(_1: NonTerminal.Expr2), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr2._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s56 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            56,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.multOp =>
                      (
                        s26,
                        (tok.left, s56) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr2), _) :: (Left(_2: Tok.addOp), _) :: (Right(_1: NonTerminal.Expr1), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr1._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Right(_3: NonTerminal.Expr2), _) :: (Left(_2: Tok.addOp), _) :: (Right(_1: NonTerminal.Expr1), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr1._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s57 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            57,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.int =>
                      (
                        s17,
                        (tok.left, s57) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.float =>
                      (
                        s48,
                        (tok.left, s57) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.variable =>
                      (
                        s4,
                        (tok.left, s57) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s37,
                        (tok.left, s57) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Expr3 =>
                s49
              case _: NonTerminal.Expr2 =>
                s56
              case _: NonTerminal.Expr4 =>
                s42
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s58 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            58,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.multOp =>
                      stack match {
                        case (Left(_1: Tok.int), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.powOp =>
                      stack match {
                        case (Left(_1: Tok.int), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`~` =>
                      stack match {
                        case (Left(_1: Tok.int), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Left(_1: Tok.int), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.int), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s59 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            59,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.powOp =>
                      stack match {
                        case (Left(_1: Tok.int), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.multOp =>
                      stack match {
                        case (Left(_1: Tok.int), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.int), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.addOp =>
                      stack match {
                        case (Left(_1: Tok.int), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Expr4._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s52
      },
    )
  
}
// format: on
