// !!! DO NOT MODIFY !!!
// File was automatically generated by slyce v2.1.4

package slyce.generate.parsers

// format: off

import scala.annotation.tailrec

import klib.Implicits._
import klib.fp.types._
import klib.utils._

import slyce.core._
import slyce.parse._

object lexer {
  
  sealed abstract class Tok(val tokName: String) extends Token
  object Tok {
    final case class char(text: String, span: Span.Highlight) extends Tok("char") with NonTerminal.CCChar.LiftType
    final case class chars(text: String, span: Span.Highlight) extends Tok("chars") with NonTerminal.Char.LiftType
    final case class escChar(text: String, span: Span.Highlight) extends Tok("escChar") with NonTerminal.Char.LiftType with NonTerminal.CCChar.LiftType
    final case class escChars(text: String, span: Span.Highlight) extends Tok("escChars")
    final case class int(text: String, span: Span.Highlight) extends Tok("int")
    final case class mode(text: String, span: Span.Highlight) extends Tok("mode")
    final case class term(text: String, span: Span.Highlight) extends Tok("term") with NonTerminal.YieldType.LiftType
    
    final case class `(`(text: String, span: Span.Highlight) extends Tok(""""("""")
    final case class `)`(text: String, span: Span.Highlight) extends Tok("""")"""")
    final case class `*`(text: String, span: Span.Highlight) extends Tok(""""*"""")
    final case class `+`(text: String, span: Span.Highlight) extends Tok(""""+"""")
    final case class `,`(text: String, span: Span.Highlight) extends Tok("""","""")
    final case class `->`(text: String, span: Span.Highlight) extends Tok(""""->"""")
    final case class `-`(text: String, span: Span.Highlight) extends Tok(""""-"""")
    final case class `;`(text: String, span: Span.Highlight) extends Tok("""";"""")
    final case class `<-`(text: String, span: Span.Highlight) extends Tok(""""<-"""")
    final case class `>>`(text: String, span: Span.Highlight) extends Tok("""">>"""")
    final case class `?`(text: String, span: Span.Highlight) extends Tok(""""?"""")
    final case class `@`(text: String, span: Span.Highlight) extends Tok(""""@"""") with NonTerminal.YieldType.LiftType
    final case class `@mode:`(text: String, span: Span.Highlight) extends Tok(""""@mode:"""")
    final case class `@start:`(text: String, span: Span.Highlight) extends Tok(""""@start:"""")
    final case class `[`(text: String, span: Span.Highlight) extends Tok(""""["""")
    final case class `\"`(text: String, span: Span.Highlight) extends Tok(""""\""""")
    final case class `]`(text: String, span: Span.Highlight) extends Tok(""""]"""")
    final case class `^`(text: String, span: Span.Highlight) extends Tok(""""^"""")
    final case class `{`(text: String, span: Span.Highlight) extends Tok(""""{"""")
    final case class `|`(text: String, span: Span.Highlight) extends Tok(""""|"""")
    final case class `}`(text: String, span: Span.Highlight) extends Tok(""""}"""")
    
    def findRawTerminal(text: String, span: Span.Highlight): Attempt[Tok] =
      text match {
        case "(" => Tok.`(`(text, span).pure[Attempt]
        case ")" => Tok.`)`(text, span).pure[Attempt]
        case "*" => Tok.`*`(text, span).pure[Attempt]
        case "+" => Tok.`+`(text, span).pure[Attempt]
        case "," => Tok.`,`(text, span).pure[Attempt]
        case "->" => Tok.`->`(text, span).pure[Attempt]
        case "-" => Tok.`-`(text, span).pure[Attempt]
        case ";" => Tok.`;`(text, span).pure[Attempt]
        case "<-" => Tok.`<-`(text, span).pure[Attempt]
        case ">>" => Tok.`>>`(text, span).pure[Attempt]
        case "?" => Tok.`?`(text, span).pure[Attempt]
        case "@" => Tok.`@`(text, span).pure[Attempt]
        case "@mode:" => Tok.`@mode:`(text, span).pure[Attempt]
        case "@start:" => Tok.`@start:`(text, span).pure[Attempt]
        case "[" => Tok.`[`(text, span).pure[Attempt]
        case "\"" => Tok.`\"`(text, span).pure[Attempt]
        case "]" => Tok.`]`(text, span).pure[Attempt]
        case "^" => Tok.`^`(text, span).pure[Attempt]
        case "{" => Tok.`{`(text, span).pure[Attempt]
        case "|" => Tok.`|`(text, span).pure[Attempt]
        case "}" => Tok.`}`(text, span).pure[Attempt]
        case _ => Dead(Marked(s"Invalid raw-terminal : ${text.unesc}", span) :: Nil)
      }
  }
  
  type NtRoot = NonTerminal.Lexer
  sealed trait NonTerminal
  object NonTerminal {
    type GroupInner = GroupInnerHead
    type Sequence = SequenceSimple
    
    sealed trait AnonList10Tail extends NonTerminal
    object AnonList10Tail {
      final case class _1(
        _0: NonTerminal.CCChars,
        _1: NonTerminal.AnonList10Tail,
      ) extends AnonList10Tail
      case object _2 extends AnonList10Tail
    }
    
    final case class AnonList1Head(
      _0: NonTerminal.Mode,
      _1: NonTerminal.AnonList2Tail,
    ) extends NonTerminal {
      
      def toNonEmptyList: NonEmptyList[AnonList1Head.LiftType] = {
        @tailrec
        def loop(queue: AnonList2Tail, stack: List[AnonList1Head.LiftType]): List[AnonList1Head.LiftType] =
          queue match {
            case head: AnonList2Tail._1 => loop(head._1, head._0 :: stack)
            case _: AnonList2Tail._2.type => stack.reverse
          }
        
        NonEmptyList[AnonList1Head.LiftType](this._0, loop(this._1, Nil))
      }
      
    }
    object AnonList1Head {
      type LiftType = NonTerminal.Mode
    }
    
    sealed trait AnonList2Tail extends NonTerminal
    object AnonList2Tail {
      final case class _1(
        _0: NonTerminal.Mode,
        _1: NonTerminal.AnonList2Tail,
      ) extends AnonList2Tail
      case object _2 extends AnonList2Tail
    }
    
    final case class AnonList3Head(
      _0: NonTerminal.Line,
      _1: NonTerminal.AnonList4Tail,
    ) extends NonTerminal {
      
      def toNonEmptyList: NonEmptyList[AnonList3Head.LiftType] = {
        @tailrec
        def loop(queue: AnonList4Tail, stack: List[AnonList3Head.LiftType]): List[AnonList3Head.LiftType] =
          queue match {
            case head: AnonList4Tail._1 => loop(head._1, head._0 :: stack)
            case _: AnonList4Tail._2.type => stack.reverse
          }
        
        NonEmptyList[AnonList3Head.LiftType](this._0, loop(this._1, Nil))
      }
      
    }
    object AnonList3Head {
      type LiftType = NonTerminal.Line
    }
    
    sealed trait AnonList4Tail extends NonTerminal
    object AnonList4Tail {
      final case class _1(
        _0: NonTerminal.Line,
        _1: NonTerminal.AnonList4Tail,
      ) extends AnonList4Tail
      case object _2 extends AnonList4Tail
    }
    
    sealed trait AnonList5Head extends NonTerminal {
      
      def toList: List[AnonList5Head.LiftType] = {
        @tailrec
        def loop(queue: AnonList6Tail, stack: List[AnonList5Head.LiftType]): List[AnonList5Head.LiftType] =
          queue match {
            case head: AnonList6Tail._1 => loop(head._2, head._1 :: stack)
            case _: AnonList6Tail._2.type => stack.reverse
          }
        
        this match {
          case head: AnonList5Head._1 => head._0 :: loop(head._1, Nil)
          case _: AnonList5Head._2.type => Nil
        }
      }
      
    }
    object AnonList5Head {
      type LiftType = NonTerminal.Yield
      
      final case class _1(
        _0: NonTerminal.Yield,
        _1: NonTerminal.AnonList6Tail,
      ) extends AnonList5Head
      case object _2 extends AnonList5Head
    }
    
    sealed trait AnonList6Tail extends NonTerminal
    object AnonList6Tail {
      final case class _1(
        _0: Tok.`,`,
        _1: NonTerminal.Yield,
        _2: NonTerminal.AnonList6Tail,
      ) extends AnonList6Tail
      case object _2 extends AnonList6Tail
    }
    
    final case class AnonList7Head(
      _0: NonTerminal.Char,
      _1: NonTerminal.AnonList8Tail,
    ) extends NonTerminal {
      
      def toNonEmptyList: NonEmptyList[AnonList7Head.LiftType] = {
        @tailrec
        def loop(queue: AnonList8Tail, stack: List[AnonList7Head.LiftType]): List[AnonList7Head.LiftType] =
          queue match {
            case head: AnonList8Tail._1 => loop(head._1, head._0 :: stack)
            case _: AnonList8Tail._2.type => stack.reverse
          }
        
        NonEmptyList[AnonList7Head.LiftType](this._0, loop(this._1, Nil))
      }
      
    }
    object AnonList7Head {
      type LiftType = NonTerminal.Char
    }
    
    sealed trait AnonList8Tail extends NonTerminal
    object AnonList8Tail {
      final case class _1(
        _0: NonTerminal.Char,
        _1: NonTerminal.AnonList8Tail,
      ) extends AnonList8Tail
      case object _2 extends AnonList8Tail
    }
    
    final case class AnonList9Head(
      _0: NonTerminal.CCChars,
      _1: NonTerminal.AnonList10Tail,
    ) extends NonTerminal {
      
      def toNonEmptyList: NonEmptyList[AnonList9Head.LiftType] = {
        @tailrec
        def loop(queue: AnonList10Tail, stack: List[AnonList9Head.LiftType]): List[AnonList9Head.LiftType] =
          queue match {
            case head: AnonList10Tail._1 => loop(head._1, head._0 :: stack)
            case _: AnonList10Tail._2.type => stack.reverse
          }
        
        NonEmptyList[AnonList9Head.LiftType](this._0, loop(this._1, Nil))
      }
      
    }
    object AnonList9Head {
      type LiftType = NonTerminal.CCChars
    }
    
    sealed trait CCChar extends NonTerminal {
      
      def lift: CCChar.LiftType =
        this match {
          case nt: CCChar._1 => nt._0
          case nt: CCChar._2 => nt._0
        }
      
    }
    object CCChar {
      sealed trait LiftType
      
      final case class _1(
        _0: Tok.char,
      ) extends CCChar
      final case class _2(
        _0: Tok.escChar,
      ) extends CCChar
    }
    
    sealed trait CCChars extends NonTerminal
    object CCChars {
      final case class _1(
        _0: NonTerminal.CCChar,
        _1: Tok.`-`,
        _2: NonTerminal.CCChar,
      ) extends CCChars
      final case class _2(
        _0: NonTerminal.CCChar,
      ) extends CCChars
      final case class _3(
        _0: Tok.escChars,
      ) extends CCChars
    }
    
    sealed trait Char extends NonTerminal {
      
      def lift: Char.LiftType =
        this match {
          case nt: Char._1 => nt._0
          case nt: Char._2 => nt._0
        }
      
    }
    object Char {
      sealed trait LiftType
      
      final case class _1(
        _0: Tok.chars,
      ) extends Char
      final case class _2(
        _0: Tok.escChar,
      ) extends Char
    }
    
    sealed trait CharClass extends NonTerminal
    object CharClass {
      final case class _1(
        _0: Tok.`[`,
        _1: NonTerminal.`Opt_^`,
        _2: NonTerminal.AnonList9Head,
        _3: Tok.`]`,
      ) extends CharClass
      final case class _2(
        _0: Tok.char,
      ) extends CharClass
      final case class _3(
        _0: Tok.escChar,
      ) extends CharClass
      final case class _4(
        _0: Tok.escChars,
      ) extends CharClass
    }
    
    final case class Group(
      _0: Tok.`(`,
      _1: NonTerminal.GroupInnerHead,
      _2: Tok.`)`,
    ) extends NonTerminal {
      
      def lift: Group.LiftType =
        this match {
          case nt: Group => nt._1
        }
      
    }
    object Group {
      type LiftType = NonTerminal.GroupInnerHead
    }
    
    final case class GroupInnerHead(
      _0: NonTerminal.SequenceSimple,
      _1: NonTerminal.GroupInnerTail,
    ) extends NonTerminal {
      
      def toNonEmptyList: NonEmptyList[GroupInnerHead.LiftType] = {
        @tailrec
        def loop(queue: GroupInnerTail, stack: List[GroupInnerHead.LiftType]): List[GroupInnerHead.LiftType] =
          queue match {
            case head: GroupInnerTail._1 => loop(head._2, head._1 :: stack)
            case _: GroupInnerTail._2.type => stack.reverse
          }
        
        NonEmptyList[GroupInnerHead.LiftType](this._0, loop(this._1, Nil))
      }
      
    }
    object GroupInnerHead {
      type LiftType = NonTerminal.SequenceSimple
    }
    
    sealed trait GroupInnerTail extends NonTerminal
    object GroupInnerTail {
      final case class _1(
        _0: Tok.`|`,
        _1: NonTerminal.SequenceSimple,
        _2: NonTerminal.GroupInnerTail,
      ) extends GroupInnerTail
      case object _2 extends GroupInnerTail
    }
    
    final case class Lexer(
      _0: Tok.`@start:`,
      _1: Tok.mode,
      _2: NonTerminal.AnonList1Head,
    ) extends NonTerminal
    
    final case class Line(
      _0: NonTerminal.GroupInnerHead,
      _1: Tok.`;`,
      _2: NonTerminal.AnonList5Head,
      _3: NonTerminal.OptToMode,
    ) extends NonTerminal
    
    final case class Mode(
      _0: Tok.`@mode:`,
      _1: Tok.mode,
      _2: NonTerminal.AnonList3Head,
    ) extends NonTerminal
    
    sealed trait OptToMode extends NonTerminal {
      
      def toMaybe: Maybe[OptToMode.LiftType] =
        this match {
          case OptToMode._1(some) => some.some
          case OptToMode._2 => None
        }
      
    }
    object OptToMode {
      type LiftType = NonTerminal.ToMode
      
      final case class _1(
        _0: NonTerminal.ToMode,
      ) extends OptToMode
      case object _2 extends OptToMode
    }
    
    sealed trait Opt_int extends NonTerminal {
      
      def toMaybe: Maybe[Opt_int.LiftType] =
        this match {
          case Opt_int._1(some) => some.some
          case Opt_int._2 => None
        }
      
    }
    object Opt_int {
      type LiftType = Tok.int
      
      final case class _1(
        _0: Tok.int,
      ) extends Opt_int
      case object _2 extends Opt_int
    }
    
    sealed trait Quant extends NonTerminal
    object Quant {
      final case class _1(
        _0: Tok.`?`,
      ) extends Quant
      final case class _2(
        _0: Tok.`*`,
      ) extends Quant
      final case class _3(
        _0: Tok.`+`,
      ) extends Quant
      final case class _4(
        _0: Tok.`{`,
        _1: NonTerminal.Opt_int,
        _2: Tok.`}`,
      ) extends Quant
      final case class _5(
        _0: Tok.`{`,
        _1: NonTerminal.Opt_int,
        _2: Tok.`,`,
        _3: NonTerminal.Opt_int,
        _4: Tok.`}`,
      ) extends Quant
    }
    
    final case class Raw(
      _0: Tok.`\"`,
      _1: NonTerminal.AnonList7Head,
      _2: Tok.`\"`,
    ) extends NonTerminal with NonTerminal.YieldType.LiftType {
      
      def lift: Raw.LiftType =
        this match {
          case nt: Raw => nt._1
        }
      
    }
    object Raw {
      type LiftType = NonTerminal.AnonList7Head
    }
    
    sealed trait Regex extends NonTerminal
    object Regex {
      final case class _1(
        _0: NonTerminal.Group,
      ) extends Regex
      final case class _2(
        _0: NonTerminal.CharClass,
      ) extends Regex
      final case class _3(
        _0: NonTerminal.Regex,
        _1: NonTerminal.Quant,
      ) extends Regex
    }
    
    sealed trait SequenceSimple extends NonTerminal {
      
      def toList: List[SequenceSimple.LiftType] = {
        @tailrec
        def loop(queue: SequenceSimple, stack: List[SequenceSimple.LiftType]): List[SequenceSimple.LiftType] =
          queue match {
            case head: SequenceSimple._1 => loop(head._1, head._0 :: stack)
            case _: SequenceSimple._2.type => stack.reverse
          }
        
        loop(this, Nil)
      }
      
    }
    object SequenceSimple {
      type LiftType = NonTerminal.Regex
      
      final case class _1(
        _0: NonTerminal.Regex,
        _1: NonTerminal.SequenceSimple,
      ) extends SequenceSimple
      case object _2 extends SequenceSimple
    }
    
    sealed trait SubString extends NonTerminal
    object SubString {
      final case class _1(
        _0: Tok.`[`,
        _1: NonTerminal.Opt_int,
        _2: Tok.`]`,
      ) extends SubString
      final case class _2(
        _0: Tok.`[`,
        _1: NonTerminal.Opt_int,
        _2: Tok.`,`,
        _3: NonTerminal.Opt_int,
        _4: Tok.`]`,
      ) extends SubString
    }
    
    sealed trait ToMode extends NonTerminal
    object ToMode {
      final case class _1(
        _0: Tok.`>>`,
        _1: Tok.mode,
      ) extends ToMode
      final case class _2(
        _0: Tok.`->`,
        _1: Tok.mode,
      ) extends ToMode
      final case class _3(
        _0: Tok.`<-`,
      ) extends ToMode
    }
    
    final case class Yield(
      _0: NonTerminal.YieldType,
      _1: NonTerminal.SubString,
    ) extends NonTerminal
    
    sealed trait YieldType extends NonTerminal {
      
      def lift: YieldType.LiftType =
        this match {
          case nt: YieldType._1 => nt._0
          case nt: YieldType._2 => nt._0
          case nt: YieldType._3 => nt._0
        }
      
    }
    object YieldType {
      sealed trait LiftType
      
      final case class _1(
        _0: Tok.`@`,
      ) extends YieldType
      final case class _2(
        _0: Tok.term,
      ) extends YieldType
      final case class _3(
        _0: NonTerminal.Raw,
      ) extends YieldType
    }
    
    sealed trait `Opt_^` extends NonTerminal {
      
      def toMaybe: Maybe[`Opt_^`.LiftType] =
        this match {
          case `Opt_^`._1(some) => some.some
          case `Opt_^`._2 => None
        }
      
    }
    object `Opt_^` {
      type LiftType = Tok.`^`
      
      final case class _1(
        _0: Tok.`^`,
      ) extends `Opt_^`
      case object _2 extends `Opt_^`
    }
    
  }
  
  lazy val parser: Parser[Tok, NonTerminal, NtRoot] =
    Parser[Tok, NonTerminal, NtRoot](
      Lexer[Tok] {
        var s0: Lexer.State[Tok] = null
        var s1: Lexer.State[Tok] = null
        var s2: Lexer.State[Tok] = null
        var s3: Lexer.State[Tok] = null
        var s4: Lexer.State[Tok] = null
        var s5: Lexer.State[Tok] = null
        var s6: Lexer.State[Tok] = null
        var s7: Lexer.State[Tok] = null
        var s8: Lexer.State[Tok] = null
        var s9: Lexer.State[Tok] = null
        var s10: Lexer.State[Tok] = null
        var s11: Lexer.State[Tok] = null
        var s12: Lexer.State[Tok] = null
        var s13: Lexer.State[Tok] = null
        var s14: Lexer.State[Tok] = null
        var s15: Lexer.State[Tok] = null
        var s16: Lexer.State[Tok] = null
        var s17: Lexer.State[Tok] = null
        var s18: Lexer.State[Tok] = null
        var s19: Lexer.State[Tok] = null
        var s20: Lexer.State[Tok] = null
        var s21: Lexer.State[Tok] = null
        var s22: Lexer.State[Tok] = null
        var s23: Lexer.State[Tok] = null
        var s24: Lexer.State[Tok] = null
        var s25: Lexer.State[Tok] = null
        var s26: Lexer.State[Tok] = null
        var s27: Lexer.State[Tok] = null
        var s28: Lexer.State[Tok] = null
        var s29: Lexer.State[Tok] = null
        var s30: Lexer.State[Tok] = null
        var s31: Lexer.State[Tok] = null
        var s32: Lexer.State[Tok] = null
        var s33: Lexer.State[Tok] = null
        var s34: Lexer.State[Tok] = null
        var s35: Lexer.State[Tok] = null
        var s36: Lexer.State[Tok] = null
        var s37: Lexer.State[Tok] = null
        var s38: Lexer.State[Tok] = null
        var s39: Lexer.State[Tok] = null
        var s40: Lexer.State[Tok] = null
        var s41: Lexer.State[Tok] = null
        var s42: Lexer.State[Tok] = null
        var s43: Lexer.State[Tok] = null
        var s44: Lexer.State[Tok] = null
        var s45: Lexer.State[Tok] = null
        var s46: Lexer.State[Tok] = null
        var s47: Lexer.State[Tok] = null
        var s48: Lexer.State[Tok] = null
        var s49: Lexer.State[Tok] = null
        var s50: Lexer.State[Tok] = null
        var s51: Lexer.State[Tok] = null
        var s52: Lexer.State[Tok] = null
        var s53: Lexer.State[Tok] = null
        var s54: Lexer.State[Tok] = null
        var s55: Lexer.State[Tok] = null
        var s56: Lexer.State[Tok] = null
        var s57: Lexer.State[Tok] = null
        var s58: Lexer.State[Tok] = null
        var s59: Lexer.State[Tok] = null
        var s60: Lexer.State[Tok] = null
        var s61: Lexer.State[Tok] = null
        var s62: Lexer.State[Tok] = null
        var s63: Lexer.State[Tok] = null
        var s64: Lexer.State[Tok] = null
        var s65: Lexer.State[Tok] = null
        var s66: Lexer.State[Tok] = null
        var s67: Lexer.State[Tok] = null
        var s68: Lexer.State[Tok] = null
        var s69: Lexer.State[Tok] = null
        
        s0 =
          Lexer.State[Tok](
            0,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (Some(1),Some(1)),
                  Tok.escChar(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s1 =
          Lexer.State[Tok](
            1,
            char => {
              val int = char.toInt
              
              if (int == 34) // '\"'
                None
              else if (int == 92) // '\\'
                None
              else
                s1.some
            },
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.chars(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s2 =
          Lexer.State[Tok](
            2,
            char => {
              val int = char.toInt
              
              if (int == 47) // '/'
                s67.some
              else
                s63.some
            },
            None,
          )
        
        s3 =
          Lexer.State[Tok](
            3,
            char => {
              val int = char.toInt
              
              if (int == 10) // '\n'
                s56.some
              else
                s3.some
            },
            None,
          )
        
        s4 =
          Lexer.State[Tok](
            4,
            char => {
              val int = char.toInt
              
              if (int == 32) // ' '
                s4.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s5 =
          Lexer.State[Tok](
            5,
            char => {
              val int = char.toInt
              
              if (int == 47) // '/'
                s38.some
              else
                s46.some
            },
            None,
          )
        
        s6 =
          Lexer.State[Tok](
            6,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.char(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s7 =
          Lexer.State[Tok](
            7,
            _ => None,
            Lexer.Yields[Tok](
              List(
              ),
              Lexer.Yields.ToMode.Pop,
            ).some,
          )
        
        s8 =
          Lexer.State[Tok](
            8,
            char => {
              val int = char.toInt
              
              if (int == 10) // '\n'
                s28.some
              else
                s8.some
            },
            None,
          )
        
        s9 =
          Lexer.State[Tok](
            9,
            char => {
              val int = char.toInt
              
              if (int >= 48 && int <= 57) // '0'-'9'
                s42.some
              else if (int == 62) // '>'
                s14.some
              else
                None
            },
            None,
          )
        
        s10 =
          Lexer.State[Tok](
            10,
            char => {
              val int = char.toInt
              
              if (int == 100) // 'd'
                s57.some
              else
                None
            },
            None,
          )
        
        s11 =
          Lexer.State[Tok](
            11,
            char => {
              val int = char.toInt
              
              if (int == 62) // '>'
                s37.some
              else if (int == 60) // '<'
                s25.some
              else if (int >= 65 && int <= 90) // 'A'-'Z'
                s68.some
              else if (int >= 48 && int <= 57) // '0'-'9'
                s42.some
              else if (int == 44) // ','
                s14.some
              else if (int == 64) // '@'
                s14.some
              else if (int == 91) // '['
                s14.some
              else if (int == 93) // ']'
                s14.some
              else if (int == 45) // '-'
                s9.some
              else if (int == 9) // '\t'
                s18.some
              else if (int == 32) // ' '
                s18.some
              else if (int >= 97 && int <= 122) // 'a'-'z'
                s59.some
              else if (int == 47) // '/'
                s39.some
              else if (int == 34) // '\"'
                s26.some
              else if (int == 10) // '\n'
                s55.some
              else
                None
            },
            None,
          )
        
        s12 =
          Lexer.State[Tok](
            12,
            char => {
              val int = char.toInt
              
              if (int == 32) // ' '
                s24.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.char(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s13 =
          Lexer.State[Tok](
            13,
            char => {
              val int = char.toInt
              
              if (int == 58) // ':'
                s54.some
              else
                None
            },
            None,
          )
        
        s14 =
          Lexer.State[Tok](
            14,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.findRawTerminal,
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s15 =
          Lexer.State[Tok](
            15,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.findRawTerminal,
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s16 =
          Lexer.State[Tok](
            16,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.findRawTerminal,
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s17 =
          Lexer.State[Tok](
            17,
            char => {
              val int = char.toInt
              
              if (int == 32) // ' '
                s4.some
              else
                None
            },
            None,
          )
        
        s18 =
          Lexer.State[Tok](
            18,
            char => {
              val int = char.toInt
              
              if (int == 9) // '\t'
                s18.some
              else if (int == 32) // ' '
                s18.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s19 =
          Lexer.State[Tok](
            19,
            char => {
              val int = char.toInt
              
              if (int == 32) // ' '
                s12.some
              else if (int >= 40 && int <= 43) // '('-'+'
                s16.some
              else if (int == 63) // '?'
                s16.some
              else if (int == 124) // '|'
                s16.some
              else if (int == 46) // '.'
                s50.some
              else if (int == 92) // '\\'
                s29.some
              else if (int == 123) // '{'
                s51.some
              else if (int == 59) // ';'
                s32.some
              else if (int == 91) // '['
                s66.some
              else if (int == 47) // '/'
                s30.some
              else if (int == 64) // '@'
                s58.some
              else if (int == 10) // '\n'
                s41.some
              else
                s65.some
            },
            None,
          )
        
        s20 =
          Lexer.State[Tok](
            20,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.findRawTerminal,
                ),
              ),
              Lexer.Yields.ToMode.Pop,
            ).some,
          )
        
        s21 =
          Lexer.State[Tok](
            21,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.findRawTerminal,
                ),
              ),
              Lexer.Yields.ToMode.Pop,
            ).some,
          )
        
        s22 =
          Lexer.State[Tok](
            22,
            char => {
              val int = char.toInt
              
              if (int == 9) // '\t'
                s22.some
              else if (int == 32) // ' '
                s22.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s23 =
          Lexer.State[Tok](
            23,
            char => {
              val int = char.toInt
              
              if (int == 92) // '\\'
                s69.some
              else if (int == 34) // '\"'
                s20.some
              else
                s1.some
            },
            None,
          )
        
        s24 =
          Lexer.State[Tok](
            24,
            char => {
              val int = char.toInt
              
              if (int == 32) // ' '
                s17.some
              else
                None
            },
            None,
          )
        
        s25 =
          Lexer.State[Tok](
            25,
            char => {
              val int = char.toInt
              
              if (int == 45) // '-'
                s14.some
              else
                None
            },
            None,
          )
        
        s26 =
          Lexer.State[Tok](
            26,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.findRawTerminal,
                ),
              ),
              Lexer.Yields.ToMode.Push[Tok](Lazy(s23)),
            ).some,
          )
        
        s27 =
          Lexer.State[Tok](
            27,
            char => {
              val int = char.toInt
              
              if (int == 45) // '-'
                s53.some
              else if (int >= 92 && int <= 94) // '\\'-'^'
                s53.some
              else if (int == 110) // 'n'
                s53.some
              else if (int == 116) // 't'
                s53.some
              else if (int == 100) // 'd'
                s45.some
              else
                None
            },
            None,
          )
        
        s28 =
          Lexer.State[Tok](
            28,
            _ => None,
            Lexer.Yields[Tok](
              List(
              ),
              Lexer.Yields.ToMode.Pop,
            ).some,
          )
        
        s29 =
          Lexer.State[Tok](
            29,
            char => {
              val int = char.toInt
              
              if (int >= 40 && int <= 43) // '('-'+'
                s0.some
              else if (int >= 46 && int <= 47) // '.'-'/'
                s0.some
              else if (int == 59) // ';'
                s0.some
              else if (int >= 63 && int <= 64) // '?'-'@'
                s0.some
              else if (int >= 91 && int <= 93) // '['-']'
                s0.some
              else if (int == 110) // 'n'
                s0.some
              else if (int == 116) // 't'
                s0.some
              else if (int >= 123 && int <= 125) // '{'-'}'
                s0.some
              else if (int == 100) // 'd'
                s31.some
              else
                None
            },
            None,
          )
        
        s30 =
          Lexer.State[Tok](
            30,
            char => {
              val int = char.toInt
              
              if (int == 42) // '*'
                s63.some
              else if (int == 47) // '/'
                s3.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.char(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s31 =
          Lexer.State[Tok](
            31,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (Some(1),Some(1)),
                  Tok.escChars(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s32 =
          Lexer.State[Tok](
            32,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.findRawTerminal,
                ),
              ),
              Lexer.Yields.ToMode.Push[Tok](Lazy(s11)),
            ).some,
          )
        
        s33 =
          Lexer.State[Tok](
            33,
            char => {
              val int = char.toInt
              
              if (int >= 48 && int <= 57) // '0'-'9'
                s52.some
              else
                None
            },
            None,
          )
        
        s34 =
          Lexer.State[Tok](
            34,
            char => {
              val int = char.toInt
              
              if (int == 97) // 'a'
                s36.some
              else
                None
            },
            None,
          )
        
        s35 =
          Lexer.State[Tok](
            35,
            char => {
              val int = char.toInt
              
              if (int == 9) // '\t'
                s35.some
              else if (int == 32) // ' '
                s35.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s36 =
          Lexer.State[Tok](
            36,
            char => {
              val int = char.toInt
              
              if (int == 114) // 'r'
                s61.some
              else
                None
            },
            None,
          )
        
        s37 =
          Lexer.State[Tok](
            37,
            char => {
              val int = char.toInt
              
              if (int == 62) // '>'
                s14.some
              else
                None
            },
            None,
          )
        
        s38 =
          Lexer.State[Tok](
            38,
            _ => None,
            Lexer.Yields[Tok](
              List(
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s39 =
          Lexer.State[Tok](
            39,
            char => {
              val int = char.toInt
              
              if (int == 47) // '/'
                s8.some
              else if (int == 42) // '*'
                s46.some
              else
                None
            },
            None,
          )
        
        s40 =
          Lexer.State[Tok](
            40,
            char => {
              val int = char.toInt
              
              if (int == 93) // ']'
                s44.some
              else if (int == 92) // '\\'
                s27.some
              else if (int == 45) // '-'
                s64.some
              else if (int == 94) // '^'
                s64.some
              else
                s6.some
            },
            None,
          )
        
        s41 =
          Lexer.State[Tok](
            41,
            _ => None,
            Lexer.Yields[Tok](
              List(
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s42 =
          Lexer.State[Tok](
            42,
            char => {
              val int = char.toInt
              
              if (int >= 48 && int <= 57) // '0'-'9'
                s42.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.int(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s43 =
          Lexer.State[Tok](
            43,
            char => {
              val int = char.toInt
              
              if (int == 111) // 'o'
                s10.some
              else
                None
            },
            None,
          )
        
        s44 =
          Lexer.State[Tok](
            44,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.findRawTerminal,
                ),
              ),
              Lexer.Yields.ToMode.Pop,
            ).some,
          )
        
        s45 =
          Lexer.State[Tok](
            45,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (Some(1),Some(1)),
                  Tok.escChars(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s46 =
          Lexer.State[Tok](
            46,
            char => {
              val int = char.toInt
              
              if (int == 42) // '*'
                s5.some
              else
                s46.some
            },
            None,
          )
        
        s47 =
          Lexer.State[Tok](
            47,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (Some(1),Some(1)),
                  Tok.escChar(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s48 =
          Lexer.State[Tok](
            48,
            char => {
              val int = char.toInt
              
              if (int >= 65 && int <= 90) // 'A'-'Z'
                s49.some
              else if (int == 10) // '\n'
                s7.some
              else if (int == 9) // '\t'
                s22.some
              else if (int == 32) // ' '
                s22.some
              else
                None
            },
            None,
          )
        
        s49 =
          Lexer.State[Tok](
            49,
            char => {
              val int = char.toInt
              
              if (int >= 48 && int <= 57) // '0'-'9'
                s49.some
              else if (int >= 65 && int <= 90) // 'A'-'Z'
                s49.some
              else if (int == 95) // '_'
                s49.some
              else if (int >= 97 && int <= 122) // 'a'-'z'
                s49.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.mode(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s50 =
          Lexer.State[Tok](
            50,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.char(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s51 =
          Lexer.State[Tok](
            51,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.findRawTerminal,
                ),
              ),
              Lexer.Yields.ToMode.Push[Tok](Lazy(s60)),
            ).some,
          )
        
        s52 =
          Lexer.State[Tok](
            52,
            char => {
              val int = char.toInt
              
              if (int >= 48 && int <= 57) // '0'-'9'
                s52.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.int(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s53 =
          Lexer.State[Tok](
            53,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (Some(1),Some(1)),
                  Tok.escChar(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s54 =
          Lexer.State[Tok](
            54,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.findRawTerminal,
                ),
              ),
              Lexer.Yields.ToMode.Push[Tok](Lazy(s48)),
            ).some,
          )
        
        s55 =
          Lexer.State[Tok](
            55,
            _ => None,
            Lexer.Yields[Tok](
              List(
              ),
              Lexer.Yields.ToMode.Pop,
            ).some,
          )
        
        s56 =
          Lexer.State[Tok](
            56,
            _ => None,
            Lexer.Yields[Tok](
              List(
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s57 =
          Lexer.State[Tok](
            57,
            char => {
              val int = char.toInt
              
              if (int == 101) // 'e'
                s13.some
              else
                None
            },
            None,
          )
        
        s58 =
          Lexer.State[Tok](
            58,
            char => {
              val int = char.toInt
              
              if (int == 115) // 's'
                s62.some
              else if (int == 109) // 'm'
                s43.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.char(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s59 =
          Lexer.State[Tok](
            59,
            char => {
              val int = char.toInt
              
              if (int >= 48 && int <= 57) // '0'-'9'
                s59.some
              else if (int >= 65 && int <= 90) // 'A'-'Z'
                s59.some
              else if (int == 95) // '_'
                s59.some
              else if (int >= 97 && int <= 122) // 'a'-'z'
                s59.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.term(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s60 =
          Lexer.State[Tok](
            60,
            char => {
              val int = char.toInt
              
              if (int == 125) // '}'
                s21.some
              else if (int >= 48 && int <= 57) // '0'-'9'
                s52.some
              else if (int == 45) // '-'
                s33.some
              else if (int == 9) // '\t'
                s35.some
              else if (int == 32) // ' '
                s35.some
              else if (int == 44) // ','
                s15.some
              else
                None
            },
            None,
          )
        
        s61 =
          Lexer.State[Tok](
            61,
            char => {
              val int = char.toInt
              
              if (int == 116) // 't'
                s13.some
              else
                None
            },
            None,
          )
        
        s62 =
          Lexer.State[Tok](
            62,
            char => {
              val int = char.toInt
              
              if (int == 116) // 't'
                s34.some
              else
                None
            },
            None,
          )
        
        s63 =
          Lexer.State[Tok](
            63,
            char => {
              val int = char.toInt
              
              if (int == 42) // '*'
                s2.some
              else
                s63.some
            },
            None,
          )
        
        s64 =
          Lexer.State[Tok](
            64,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.findRawTerminal,
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s65 =
          Lexer.State[Tok](
            65,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.char(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s66 =
          Lexer.State[Tok](
            66,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.findRawTerminal,
                ),
              ),
              Lexer.Yields.ToMode.Push[Tok](Lazy(s40)),
            ).some,
          )
        
        s67 =
          Lexer.State[Tok](
            67,
            _ => None,
            Lexer.Yields[Tok](
              List(
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s68 =
          Lexer.State[Tok](
            68,
            char => {
              val int = char.toInt
              
              if (int >= 48 && int <= 57) // '0'-'9'
                s68.some
              else if (int >= 65 && int <= 90) // 'A'-'Z'
                s68.some
              else if (int == 95) // '_'
                s68.some
              else if (int >= 97 && int <= 122) // 'a'-'z'
                s68.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.mode(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s69 =
          Lexer.State[Tok](
            69,
            char => {
              val int = char.toInt
              
              if (int == 34) // '\"'
                s47.some
              else if (int == 92) // '\\'
                s47.some
              else if (int == 110) // 'n'
                s47.some
              else if (int == 116) // 't'
                s47.some
              else
                None
            },
            None,
          )
        
        
        s19
      },
      Grammar[Tok, NonTerminal, NtRoot] {
        var s0: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s1: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s2: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s3: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s4: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s5: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s6: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s7: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s8: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s9: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s10: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s11: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s12: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s13: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s14: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s15: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s16: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s17: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s18: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s19: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s20: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s21: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s22: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s23: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s24: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s25: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s26: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s27: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s28: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s29: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s30: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s31: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s32: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s33: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s34: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s35: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s36: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s37: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s38: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s39: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s40: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s41: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s42: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s43: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s44: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s45: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s46: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s47: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s48: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s49: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s50: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s51: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s52: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s53: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s54: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s55: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s56: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s57: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s58: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s59: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s60: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s61: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s62: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s63: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s64: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s65: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s66: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s67: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s68: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s69: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s70: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s71: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s72: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s73: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s74: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s75: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s76: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s77: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s78: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s79: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s80: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s81: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s82: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s83: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s84: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s85: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s86: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s87: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s88: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s89: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s90: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s91: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s92: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s93: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s94: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s95: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s96: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s97: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s98: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s99: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s100: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s101: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s102: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s103: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s104: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s105: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s106: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s107: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s108: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s109: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s110: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s111: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s112: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s113: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s114: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s115: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s116: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s117: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s118: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s119: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s120: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s121: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s122: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s123: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s124: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s125: Grammar.State[Tok, NonTerminal, NtRoot] = null
        
        s0 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            0,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.mode =>
                      (
                        s34,
                        (tok.left, s0) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s1 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            1,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s15,
                        (tok.left, s1) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s2 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            2,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.int =>
                      (
                        s109,
                        (tok.left, s2) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`}` =>
                      val nt: NonTerminal = NonTerminal.Opt_int._2
                      val to = s2.onNt(nt) 
                      (
                        to,
                        (nt.right, s2) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Opt_int =>
                s73
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s3 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            3,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`*` =>
                      stack match {
                        case (Right(_1: NonTerminal.Group), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Right(_1: NonTerminal.Group), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Right(_1: NonTerminal.Group), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.Group), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Right(_1: NonTerminal.Group), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Right(_1: NonTerminal.Group), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Right(_1: NonTerminal.Group), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Group), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_1: NonTerminal.Group), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Right(_1: NonTerminal.Group), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Group), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s4 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            4,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`^` =>
                      (
                        s123,
                        (tok.left, s4) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.escChars =>
                      val nt: NonTerminal = NonTerminal.`Opt_^`._2
                      val to = s4.onNt(nt) 
                      (
                        to,
                        (nt.right, s4) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.char =>
                      val nt: NonTerminal = NonTerminal.`Opt_^`._2
                      val to = s4.onNt(nt) 
                      (
                        to,
                        (nt.right, s4) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.escChar =>
                      val nt: NonTerminal = NonTerminal.`Opt_^`._2
                      val to = s4.onNt(nt) 
                      (
                        to,
                        (nt.right, s4) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.`Opt_^` =>
                s90
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s5 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            5,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`]` =>
                      (
                        s57,
                        (tok.left, s5) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s6 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            6,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_1: NonTerminal.CharClass), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`*` =>
                      stack match {
                        case (Right(_1: NonTerminal.CharClass), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Right(_1: NonTerminal.CharClass), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Right(_1: NonTerminal.CharClass), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.CharClass), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Right(_1: NonTerminal.CharClass), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Right(_1: NonTerminal.CharClass), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Right(_1: NonTerminal.CharClass), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_1: NonTerminal.CharClass), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Right(_1: NonTerminal.CharClass), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.CharClass), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s7 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            7,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList8Tail), _) :: (Right(_1: NonTerminal.Char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList8Tail._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s8 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            8,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      stack match {
                        case (Right(_1: NonTerminal.ToMode), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.OptToMode._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.ToMode), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.OptToMode._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Right(_1: NonTerminal.ToMode), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.OptToMode._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Right(_1: NonTerminal.ToMode), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.OptToMode._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`@mode:` =>
                      stack match {
                        case (Right(_1: NonTerminal.ToMode), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.OptToMode._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.ToMode), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.OptToMode._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_1: NonTerminal.ToMode), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.OptToMode._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Right(_1: NonTerminal.ToMode), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.OptToMode._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  stack match {
                    case (Right(_1: NonTerminal.ToMode), poppedState) :: stack =>
                      val nt: NonTerminal = NonTerminal.OptToMode._1(_1)
                      val to = poppedState.onNt(nt)
                      (
                        to,
                        (nt.right, poppedState) :: stack,
                        None,
                      ).left.some
                    case _ =>
                      None
                  }
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s9 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            9,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.chars =>
                      (
                        s77,
                        (tok.left, s9) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.escChar =>
                      (
                        s60,
                        (tok.left, s9) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.AnonList8Tail._2
                      val to = s9.onNt(nt) 
                      (
                        to,
                        (nt.right, s9) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Char =>
                s47
              case _: NonTerminal.AnonList8Tail =>
                s17
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s10 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            10,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`*` =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s11 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            11,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s23,
                        (tok.left, s11) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s27,
                        (tok.left, s11) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`[` =>
                      (
                        s4,
                        (tok.left, s11) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.escChars =>
                      (
                        s35,
                        (tok.left, s11) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`@mode:` =>
                      val nt: NonTerminal = NonTerminal.AnonList4Tail._2
                      val to = s11.onNt(nt) 
                      (
                        to,
                        (nt.right, s11) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.SequenceSimple._2
                      val to = s11.onNt(nt) 
                      (
                        to,
                        (nt.right, s11) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.SequenceSimple._2
                      val to = s11.onNt(nt) 
                      (
                        to,
                        (nt.right, s11) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.char =>
                      (
                        s92,
                        (tok.left, s11) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  val nt: NonTerminal = NonTerminal.AnonList4Tail._2
                  val to = s11.onNt(nt) 
                  (
                    to,
                    (nt.right, s11) :: stack,
                    None,
                  ).left.some
              }
            },
            {
              case _: NonTerminal.GroupInnerHead =>
                s51
              case _: NonTerminal.CharClass =>
                s53
              case _: NonTerminal.Regex =>
                s19
              case _: NonTerminal.AnonList4Tail =>
                s114
              case _: NonTerminal.SequenceSimple =>
                s12
              case _: NonTerminal.Group =>
                s3
              case _: NonTerminal.Line =>
                s11
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s12 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            12,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`|` =>
                      (
                        s96,
                        (tok.left, s12) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.GroupInnerTail._2
                      val to = s12.onNt(nt) 
                      (
                        to,
                        (nt.right, s12) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.GroupInnerTail =>
                s22
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s13 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            13,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      val to = s13.onNt(nt) 
                      (
                        to,
                        (nt.right, s13) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`,` =>
                      (
                        s89,
                        (tok.left, s13) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      val to = s13.onNt(nt) 
                      (
                        to,
                        (nt.right, s13) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`<-` =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      val to = s13.onNt(nt) 
                      (
                        to,
                        (nt.right, s13) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`[` =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      val to = s13.onNt(nt) 
                      (
                        to,
                        (nt.right, s13) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`->` =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      val to = s13.onNt(nt) 
                      (
                        to,
                        (nt.right, s13) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.escChars =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      val to = s13.onNt(nt) 
                      (
                        to,
                        (nt.right, s13) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`@mode:` =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      val to = s13.onNt(nt) 
                      (
                        to,
                        (nt.right, s13) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      val to = s13.onNt(nt) 
                      (
                        to,
                        (nt.right, s13) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      val to = s13.onNt(nt) 
                      (
                        to,
                        (nt.right, s13) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.char =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      val to = s13.onNt(nt) 
                      (
                        to,
                        (nt.right, s13) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`>>` =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      val to = s13.onNt(nt) 
                      (
                        to,
                        (nt.right, s13) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                  val to = s13.onNt(nt) 
                  (
                    to,
                    (nt.right, s13) :: stack,
                    None,
                  ).left.some
              }
            },
            {
              case _: NonTerminal.AnonList6Tail =>
                s79
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s14 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            14,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.`+`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`*` =>
                      stack match {
                        case (Left(_1: Tok.`+`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_1: Tok.`+`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Left(_1: Tok.`+`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`+`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Left(_1: Tok.`+`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_1: Tok.`+`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_1: Tok.`+`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.`+`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_1: Tok.`+`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.`+`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s15 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            15,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`*` =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.GroupInnerHead), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Group(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.GroupInnerHead), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Group(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.GroupInnerHead), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Group(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.GroupInnerHead), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Group(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.GroupInnerHead), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Group(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.GroupInnerHead), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Group(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.GroupInnerHead), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Group(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.GroupInnerHead), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Group(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.GroupInnerHead), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Group(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.GroupInnerHead), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Group(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.GroupInnerHead), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Group(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s16 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            16,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_1: Tok.term), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.YieldType._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s17 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            17,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList8Tail), _) :: (Right(_1: NonTerminal.Char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList7Head(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s18 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            18,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`[` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.YieldType._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s19 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            19,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`*` =>
                      (
                        s28,
                        (tok.left, s19) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.escChar =>
                      (
                        s23,
                        (tok.left, s19) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`+` =>
                      (
                        s84,
                        (tok.left, s19) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s27,
                        (tok.left, s19) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`{` =>
                      (
                        s41,
                        (tok.left, s19) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`[` =>
                      (
                        s4,
                        (tok.left, s19) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.escChars =>
                      (
                        s35,
                        (tok.left, s19) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.SequenceSimple._2
                      val to = s19.onNt(nt) 
                      (
                        to,
                        (nt.right, s19) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.SequenceSimple._2
                      val to = s19.onNt(nt) 
                      (
                        to,
                        (nt.right, s19) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.char =>
                      (
                        s92,
                        (tok.left, s19) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`?` =>
                      (
                        s32,
                        (tok.left, s19) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.CharClass =>
                s53
              case _: NonTerminal.Regex =>
                s19
              case _: NonTerminal.SequenceSimple =>
                s108
              case _: NonTerminal.Group =>
                s3
              case _: NonTerminal.Quant =>
                s74
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s20 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            20,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`@mode:` =>
                      (
                        s0,
                        (tok.left, s20) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.AnonList1Head =>
                s120
              case _: NonTerminal.Mode =>
                s113
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s21 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            21,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_2: NonTerminal.GroupInnerTail), _) :: (Right(_1: NonTerminal.SequenceSimple), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.GroupInnerHead(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s22 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            22,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.GroupInnerTail), _) :: (Right(_1: NonTerminal.SequenceSimple), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.GroupInnerHead(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s23 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            23,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`*` =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s24 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            24,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`*` =>
                      stack match {
                        case (Left(_4: Tok.`]`), _) :: (Right(_3: NonTerminal.AnonList9Head), _) :: (Right(_2: NonTerminal.`Opt_^`), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._1(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_4: Tok.`]`), _) :: (Right(_3: NonTerminal.AnonList9Head), _) :: (Right(_2: NonTerminal.`Opt_^`), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._1(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Left(_4: Tok.`]`), _) :: (Right(_3: NonTerminal.AnonList9Head), _) :: (Right(_2: NonTerminal.`Opt_^`), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._1(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_4: Tok.`]`), _) :: (Right(_3: NonTerminal.AnonList9Head), _) :: (Right(_2: NonTerminal.`Opt_^`), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._1(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Left(_4: Tok.`]`), _) :: (Right(_3: NonTerminal.AnonList9Head), _) :: (Right(_2: NonTerminal.`Opt_^`), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._1(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_4: Tok.`]`), _) :: (Right(_3: NonTerminal.AnonList9Head), _) :: (Right(_2: NonTerminal.`Opt_^`), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._1(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_4: Tok.`]`), _) :: (Right(_3: NonTerminal.AnonList9Head), _) :: (Right(_2: NonTerminal.`Opt_^`), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._1(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_4: Tok.`]`), _) :: (Right(_3: NonTerminal.AnonList9Head), _) :: (Right(_2: NonTerminal.`Opt_^`), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._1(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_4: Tok.`]`), _) :: (Right(_3: NonTerminal.AnonList9Head), _) :: (Right(_2: NonTerminal.`Opt_^`), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._1(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_4: Tok.`]`), _) :: (Right(_3: NonTerminal.AnonList9Head), _) :: (Right(_2: NonTerminal.`Opt_^`), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._1(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.`]`), _) :: (Right(_3: NonTerminal.AnonList9Head), _) :: (Right(_2: NonTerminal.`Opt_^`), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._1(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s25 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            25,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      stack match {
                        case (Right(_4: NonTerminal.OptToMode), _) :: (Right(_3: NonTerminal.AnonList5Head), _) :: (Left(_2: Tok.`;`), _) :: (Right(_1: NonTerminal.GroupInnerHead), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Line(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_4: NonTerminal.OptToMode), _) :: (Right(_3: NonTerminal.AnonList5Head), _) :: (Left(_2: Tok.`;`), _) :: (Right(_1: NonTerminal.GroupInnerHead), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Line(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Right(_4: NonTerminal.OptToMode), _) :: (Right(_3: NonTerminal.AnonList5Head), _) :: (Left(_2: Tok.`;`), _) :: (Right(_1: NonTerminal.GroupInnerHead), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Line(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Right(_4: NonTerminal.OptToMode), _) :: (Right(_3: NonTerminal.AnonList5Head), _) :: (Left(_2: Tok.`;`), _) :: (Right(_1: NonTerminal.GroupInnerHead), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Line(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`@mode:` =>
                      stack match {
                        case (Right(_4: NonTerminal.OptToMode), _) :: (Right(_3: NonTerminal.AnonList5Head), _) :: (Left(_2: Tok.`;`), _) :: (Right(_1: NonTerminal.GroupInnerHead), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Line(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_4: NonTerminal.OptToMode), _) :: (Right(_3: NonTerminal.AnonList5Head), _) :: (Left(_2: Tok.`;`), _) :: (Right(_1: NonTerminal.GroupInnerHead), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Line(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_4: NonTerminal.OptToMode), _) :: (Right(_3: NonTerminal.AnonList5Head), _) :: (Left(_2: Tok.`;`), _) :: (Right(_1: NonTerminal.GroupInnerHead), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Line(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Right(_4: NonTerminal.OptToMode), _) :: (Right(_3: NonTerminal.AnonList5Head), _) :: (Left(_2: Tok.`;`), _) :: (Right(_1: NonTerminal.GroupInnerHead), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Line(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  stack match {
                    case (Right(_4: NonTerminal.OptToMode), _) :: (Right(_3: NonTerminal.AnonList5Head), _) :: (Left(_2: Tok.`;`), _) :: (Right(_1: NonTerminal.GroupInnerHead), poppedState) :: stack =>
                      val nt: NonTerminal = NonTerminal.Line(_1, _2, _3, _4)
                      val to = poppedState.onNt(nt)
                      (
                        to,
                        (nt.right, poppedState) :: stack,
                        None,
                      ).left.some
                    case _ =>
                      None
                  }
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s26 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            26,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`*` =>
                      stack match {
                        case (Left(_3: Tok.`}`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_3: Tok.`}`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Left(_3: Tok.`}`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`}`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Left(_3: Tok.`}`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_3: Tok.`}`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_3: Tok.`}`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_3: Tok.`}`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_3: Tok.`}`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_3: Tok.`}`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`}`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s27 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            27,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      val nt: NonTerminal = NonTerminal.SequenceSimple._2
                      val to = s27.onNt(nt) 
                      (
                        to,
                        (nt.right, s27) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.escChar =>
                      (
                        s10,
                        (tok.left, s27) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s82,
                        (tok.left, s27) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`[` =>
                      (
                        s100,
                        (tok.left, s27) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.escChars =>
                      (
                        s124,
                        (tok.left, s27) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.SequenceSimple._2
                      val to = s27.onNt(nt) 
                      (
                        to,
                        (nt.right, s27) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.char =>
                      (
                        s78,
                        (tok.left, s27) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.GroupInnerHead =>
                s1
              case _: NonTerminal.CharClass =>
                s6
              case _: NonTerminal.Regex =>
                s75
              case _: NonTerminal.SequenceSimple =>
                s38
              case _: NonTerminal.Group =>
                s106
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s28 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            28,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`*` =>
                      stack match {
                        case (Left(_1: Tok.`*`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_1: Tok.`*`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Left(_1: Tok.`*`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`*`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Left(_1: Tok.`*`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_1: Tok.`*`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_1: Tok.`*`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.`*`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.`*`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_1: Tok.`*`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.`*`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s29 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            29,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.mode =>
                      (
                        s118,
                        (tok.left, s29) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s30 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            30,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`]` =>
                      stack match {
                        case (Right(_3: NonTerminal.CCChar), _) :: (Left(_2: Tok.`-`), _) :: (Right(_1: NonTerminal.CCChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChars._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Right(_3: NonTerminal.CCChar), _) :: (Left(_2: Tok.`-`), _) :: (Right(_1: NonTerminal.CCChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChars._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Right(_3: NonTerminal.CCChar), _) :: (Left(_2: Tok.`-`), _) :: (Right(_1: NonTerminal.CCChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChars._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Right(_3: NonTerminal.CCChar), _) :: (Left(_2: Tok.`-`), _) :: (Right(_1: NonTerminal.CCChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChars._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s31 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            31,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.int =>
                      (
                        s109,
                        (tok.left, s31) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`}` =>
                      val nt: NonTerminal = NonTerminal.Opt_int._2
                      val to = s31.onNt(nt) 
                      (
                        to,
                        (nt.right, s31) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Opt_int =>
                s42
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s32 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            32,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`*` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s33 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            33,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_5: Tok.`}`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._5(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`*` =>
                      stack match {
                        case (Left(_5: Tok.`}`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._5(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_5: Tok.`}`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._5(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Left(_5: Tok.`}`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._5(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_5: Tok.`}`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._5(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Left(_5: Tok.`}`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._5(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_5: Tok.`}`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._5(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_5: Tok.`}`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._5(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_5: Tok.`}`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._5(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_5: Tok.`}`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._5(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_5: Tok.`}`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._5(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s34 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            34,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s23,
                        (tok.left, s34) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s27,
                        (tok.left, s34) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`[` =>
                      (
                        s4,
                        (tok.left, s34) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.escChars =>
                      (
                        s35,
                        (tok.left, s34) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.SequenceSimple._2
                      val to = s34.onNt(nt) 
                      (
                        to,
                        (nt.right, s34) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.SequenceSimple._2
                      val to = s34.onNt(nt) 
                      (
                        to,
                        (nt.right, s34) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.char =>
                      (
                        s92,
                        (tok.left, s34) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.GroupInnerHead =>
                s51
              case _: NonTerminal.CharClass =>
                s53
              case _: NonTerminal.Regex =>
                s19
              case _: NonTerminal.AnonList3Head =>
                s81
              case _: NonTerminal.SequenceSimple =>
                s12
              case _: NonTerminal.Group =>
                s3
              case _: NonTerminal.Line =>
                s67
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s35 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            35,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`*` =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s36 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            36,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`*` =>
                      stack match {
                        case (Left(_5: Tok.`}`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._5(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_5: Tok.`}`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._5(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Left(_5: Tok.`}`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._5(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_5: Tok.`}`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._5(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Left(_5: Tok.`}`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._5(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_5: Tok.`}`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._5(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_5: Tok.`}`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._5(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_5: Tok.`}`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._5(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_5: Tok.`}`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._5(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_5: Tok.`}`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._5(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_5: Tok.`}`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._5(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s37 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            37,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`@mode:` =>
                      (
                        s0,
                        (tok.left, s37) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  val nt: NonTerminal = NonTerminal.AnonList2Tail._2
                  val to = s37.onNt(nt) 
                  (
                    to,
                    (nt.right, s37) :: stack,
                    None,
                  ).left.some
              }
            },
            {
              case _: NonTerminal.AnonList2Tail =>
                s40
              case _: NonTerminal.Mode =>
                s37
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s38 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            38,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`|` =>
                      (
                        s62,
                        (tok.left, s38) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`)` =>
                      val nt: NonTerminal = NonTerminal.GroupInnerTail._2
                      val to = s38.onNt(nt) 
                      (
                        to,
                        (nt.right, s38) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.GroupInnerTail =>
                s21
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s39 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            39,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChars =>
                      (
                        s101,
                        (tok.left, s39) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.escChar =>
                      (
                        s116,
                        (tok.left, s39) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.char =>
                      (
                        s104,
                        (tok.left, s39) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.AnonList9Head =>
                s5
              case _: NonTerminal.CCChars =>
                s50
              case _: NonTerminal.CCChar =>
                s56
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s40 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            40,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok =>
                      None
                  }
                case None =>
                  stack match {
                    case (Right(_2: NonTerminal.AnonList2Tail), _) :: (Right(_1: NonTerminal.Mode), poppedState) :: stack =>
                      val nt: NonTerminal = NonTerminal.AnonList2Tail._1(_1, _2)
                      val to = poppedState.onNt(nt)
                      (
                        to,
                        (nt.right, poppedState) :: stack,
                        None,
                      ).left.some
                    case _ =>
                      None
                  }
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s41 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            41,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.int =>
                      (
                        s64,
                        (tok.left, s41) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`,` =>
                      val nt: NonTerminal = NonTerminal.Opt_int._2
                      val to = s41.onNt(nt) 
                      (
                        to,
                        (nt.right, s41) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`}` =>
                      val nt: NonTerminal = NonTerminal.Opt_int._2
                      val to = s41.onNt(nt) 
                      (
                        to,
                        (nt.right, s41) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Opt_int =>
                s86
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s42 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            42,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`}` =>
                      (
                        s33,
                        (tok.left, s42) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s43 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            43,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      stack match {
                        case (Right(_3: NonTerminal.AnonList6Tail), _) :: (Right(_2: NonTerminal.Yield), _) :: (Left(_1: Tok.`,`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList6Tail._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_3: NonTerminal.AnonList6Tail), _) :: (Right(_2: NonTerminal.Yield), _) :: (Left(_1: Tok.`,`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList6Tail._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`<-` =>
                      stack match {
                        case (Right(_3: NonTerminal.AnonList6Tail), _) :: (Right(_2: NonTerminal.Yield), _) :: (Left(_1: Tok.`,`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList6Tail._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Right(_3: NonTerminal.AnonList6Tail), _) :: (Right(_2: NonTerminal.Yield), _) :: (Left(_1: Tok.`,`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList6Tail._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`->` =>
                      stack match {
                        case (Right(_3: NonTerminal.AnonList6Tail), _) :: (Right(_2: NonTerminal.Yield), _) :: (Left(_1: Tok.`,`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList6Tail._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Right(_3: NonTerminal.AnonList6Tail), _) :: (Right(_2: NonTerminal.Yield), _) :: (Left(_1: Tok.`,`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList6Tail._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`@mode:` =>
                      stack match {
                        case (Right(_3: NonTerminal.AnonList6Tail), _) :: (Right(_2: NonTerminal.Yield), _) :: (Left(_1: Tok.`,`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList6Tail._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_3: NonTerminal.AnonList6Tail), _) :: (Right(_2: NonTerminal.Yield), _) :: (Left(_1: Tok.`,`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList6Tail._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_3: NonTerminal.AnonList6Tail), _) :: (Right(_2: NonTerminal.Yield), _) :: (Left(_1: Tok.`,`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList6Tail._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Right(_3: NonTerminal.AnonList6Tail), _) :: (Right(_2: NonTerminal.Yield), _) :: (Left(_1: Tok.`,`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList6Tail._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`>>` =>
                      stack match {
                        case (Right(_3: NonTerminal.AnonList6Tail), _) :: (Right(_2: NonTerminal.Yield), _) :: (Left(_1: Tok.`,`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList6Tail._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  stack match {
                    case (Right(_3: NonTerminal.AnonList6Tail), _) :: (Right(_2: NonTerminal.Yield), _) :: (Left(_1: Tok.`,`), poppedState) :: stack =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._1(_1, _2, _3)
                      val to = poppedState.onNt(nt)
                      (
                        to,
                        (nt.right, poppedState) :: stack,
                        None,
                      ).left.some
                    case _ =>
                      None
                  }
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s44 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            44,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`]` =>
                      stack match {
                        case (Left(_1: Tok.int), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Opt_int._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`,` =>
                      stack match {
                        case (Left(_1: Tok.int), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Opt_int._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s45 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            45,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`]` =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChar._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChar._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChar._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChar._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s46 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            46,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok =>
                      None
                  }
                case None =>
                  stack match {
                    case (Right(_2: NonTerminal.AnonList2Tail), _) :: (Right(_1: NonTerminal.Mode), poppedState) :: stack =>
                      val nt: NonTerminal = NonTerminal.AnonList1Head(_1, _2)
                      val to = poppedState.onNt(nt)
                      (
                        to,
                        (nt.right, poppedState) :: stack,
                        None,
                      ).left.some
                    case _ =>
                      None
                  }
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s47 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            47,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.chars =>
                      (
                        s77,
                        (tok.left, s47) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.escChar =>
                      (
                        s60,
                        (tok.left, s47) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.AnonList8Tail._2
                      val to = s47.onNt(nt) 
                      (
                        to,
                        (nt.right, s47) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Char =>
                s47
              case _: NonTerminal.AnonList8Tail =>
                s7
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s48 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            48,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`]` =>
                      stack match {
                        case (Left(_1: Tok.int), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Opt_int._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s49 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            49,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.mode =>
                      (
                        s61,
                        (tok.left, s49) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s50 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            50,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChars =>
                      (
                        s101,
                        (tok.left, s50) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.escChar =>
                      (
                        s116,
                        (tok.left, s50) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.char =>
                      (
                        s104,
                        (tok.left, s50) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`]` =>
                      val nt: NonTerminal = NonTerminal.AnonList10Tail._2
                      val to = s50.onNt(nt) 
                      (
                        to,
                        (nt.right, s50) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.AnonList10Tail =>
                s112
              case _: NonTerminal.CCChars =>
                s88
              case _: NonTerminal.CCChar =>
                s56
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s51 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            51,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      (
                        s66,
                        (tok.left, s51) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s52 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            52,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`|` =>
                      (
                        s62,
                        (tok.left, s52) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`)` =>
                      val nt: NonTerminal = NonTerminal.GroupInnerTail._2
                      val to = s52.onNt(nt) 
                      (
                        to,
                        (nt.right, s52) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.GroupInnerTail =>
                s111
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s53 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            53,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`*` =>
                      stack match {
                        case (Right(_1: NonTerminal.CharClass), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Right(_1: NonTerminal.CharClass), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Right(_1: NonTerminal.CharClass), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.CharClass), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Right(_1: NonTerminal.CharClass), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Right(_1: NonTerminal.CharClass), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Right(_1: NonTerminal.CharClass), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.CharClass), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_1: NonTerminal.CharClass), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Right(_1: NonTerminal.CharClass), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.CharClass), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s54 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            54,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s122,
                        (tok.left, s54) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s55 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            55,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`@start:` =>
                      (
                        s95,
                        (tok.left, s55) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Lexer =>
                s83
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s56 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            56,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      stack match {
                        case (Right(_1: NonTerminal.CCChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChars._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`-` =>
                      (
                        s58,
                        (tok.left, s56) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`]` =>
                      stack match {
                        case (Right(_1: NonTerminal.CCChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChars._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Right(_1: NonTerminal.CCChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChars._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Right(_1: NonTerminal.CCChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChars._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s57 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            57,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_4: Tok.`]`), _) :: (Right(_3: NonTerminal.AnonList9Head), _) :: (Right(_2: NonTerminal.`Opt_^`), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._1(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`*` =>
                      stack match {
                        case (Left(_4: Tok.`]`), _) :: (Right(_3: NonTerminal.AnonList9Head), _) :: (Right(_2: NonTerminal.`Opt_^`), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._1(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_4: Tok.`]`), _) :: (Right(_3: NonTerminal.AnonList9Head), _) :: (Right(_2: NonTerminal.`Opt_^`), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._1(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Left(_4: Tok.`]`), _) :: (Right(_3: NonTerminal.AnonList9Head), _) :: (Right(_2: NonTerminal.`Opt_^`), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._1(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_4: Tok.`]`), _) :: (Right(_3: NonTerminal.AnonList9Head), _) :: (Right(_2: NonTerminal.`Opt_^`), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._1(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Left(_4: Tok.`]`), _) :: (Right(_3: NonTerminal.AnonList9Head), _) :: (Right(_2: NonTerminal.`Opt_^`), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._1(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_4: Tok.`]`), _) :: (Right(_3: NonTerminal.AnonList9Head), _) :: (Right(_2: NonTerminal.`Opt_^`), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._1(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_4: Tok.`]`), _) :: (Right(_3: NonTerminal.AnonList9Head), _) :: (Right(_2: NonTerminal.`Opt_^`), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._1(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_4: Tok.`]`), _) :: (Right(_3: NonTerminal.AnonList9Head), _) :: (Right(_2: NonTerminal.`Opt_^`), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._1(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_4: Tok.`]`), _) :: (Right(_3: NonTerminal.AnonList9Head), _) :: (Right(_2: NonTerminal.`Opt_^`), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._1(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.`]`), _) :: (Right(_3: NonTerminal.AnonList9Head), _) :: (Right(_2: NonTerminal.`Opt_^`), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._1(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s58 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            58,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.char =>
                      (
                        s71,
                        (tok.left, s58) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.escChar =>
                      (
                        s45,
                        (tok.left, s58) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.CCChar =>
                s30
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s59 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            59,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_1: Tok.`<-`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ToMode._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`<-`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ToMode._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_1: Tok.`<-`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ToMode._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_1: Tok.`<-`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ToMode._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`@mode:` =>
                      stack match {
                        case (Left(_1: Tok.`<-`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ToMode._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.`<-`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ToMode._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.`<-`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ToMode._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_1: Tok.`<-`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ToMode._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  stack match {
                    case (Left(_1: Tok.`<-`), poppedState) :: stack =>
                      val nt: NonTerminal = NonTerminal.ToMode._3(_1)
                      val to = poppedState.onNt(nt)
                      (
                        to,
                        (nt.right, poppedState) :: stack,
                        None,
                      ).left.some
                    case _ =>
                      None
                  }
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s60 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            60,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Char._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.chars =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Char._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Char._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s61 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            61,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_2: Tok.mode), _) :: (Left(_1: Tok.`>>`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ToMode._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_2: Tok.mode), _) :: (Left(_1: Tok.`>>`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ToMode._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_2: Tok.mode), _) :: (Left(_1: Tok.`>>`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ToMode._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_2: Tok.mode), _) :: (Left(_1: Tok.`>>`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ToMode._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`@mode:` =>
                      stack match {
                        case (Left(_2: Tok.mode), _) :: (Left(_1: Tok.`>>`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ToMode._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_2: Tok.mode), _) :: (Left(_1: Tok.`>>`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ToMode._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_2: Tok.mode), _) :: (Left(_1: Tok.`>>`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ToMode._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_2: Tok.mode), _) :: (Left(_1: Tok.`>>`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ToMode._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  stack match {
                    case (Left(_2: Tok.mode), _) :: (Left(_1: Tok.`>>`), poppedState) :: stack =>
                      val nt: NonTerminal = NonTerminal.ToMode._1(_1, _2)
                      val to = poppedState.onNt(nt)
                      (
                        to,
                        (nt.right, poppedState) :: stack,
                        None,
                      ).left.some
                    case _ =>
                      None
                  }
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s62 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            62,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      val nt: NonTerminal = NonTerminal.SequenceSimple._2
                      val to = s62.onNt(nt) 
                      (
                        to,
                        (nt.right, s62) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.escChar =>
                      (
                        s10,
                        (tok.left, s62) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s82,
                        (tok.left, s62) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`[` =>
                      (
                        s100,
                        (tok.left, s62) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.escChars =>
                      (
                        s124,
                        (tok.left, s62) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.SequenceSimple._2
                      val to = s62.onNt(nt) 
                      (
                        to,
                        (nt.right, s62) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.char =>
                      (
                        s78,
                        (tok.left, s62) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.CharClass =>
                s6
              case _: NonTerminal.Regex =>
                s75
              case _: NonTerminal.SequenceSimple =>
                s52
              case _: NonTerminal.Group =>
                s106
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s63 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            63,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.`*`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`*` =>
                      stack match {
                        case (Left(_1: Tok.`*`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_1: Tok.`*`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Left(_1: Tok.`*`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`*`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Left(_1: Tok.`*`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_1: Tok.`*`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_1: Tok.`*`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.`*`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_1: Tok.`*`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.`*`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s64 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            64,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`,` =>
                      stack match {
                        case (Left(_1: Tok.int), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Opt_int._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`}` =>
                      stack match {
                        case (Left(_1: Tok.int), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Opt_int._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s65 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            65,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_3: Tok.`}`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`*` =>
                      stack match {
                        case (Left(_3: Tok.`}`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_3: Tok.`}`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Left(_3: Tok.`}`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`}`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Left(_3: Tok.`}`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_3: Tok.`}`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_3: Tok.`}`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_3: Tok.`}`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_3: Tok.`}`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`}`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`{`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._4(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s66 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            66,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      val nt: NonTerminal = NonTerminal.AnonList5Head._2
                      val to = s66.onNt(nt) 
                      (
                        to,
                        (nt.right, s66) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`@` =>
                      (
                        s76,
                        (tok.left, s66) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.AnonList5Head._2
                      val to = s66.onNt(nt) 
                      (
                        to,
                        (nt.right, s66) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`<-` =>
                      val nt: NonTerminal = NonTerminal.AnonList5Head._2
                      val to = s66.onNt(nt) 
                      (
                        to,
                        (nt.right, s66) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s72,
                        (tok.left, s66) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`[` =>
                      val nt: NonTerminal = NonTerminal.AnonList5Head._2
                      val to = s66.onNt(nt) 
                      (
                        to,
                        (nt.right, s66) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.term =>
                      (
                        s16,
                        (tok.left, s66) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`->` =>
                      val nt: NonTerminal = NonTerminal.AnonList5Head._2
                      val to = s66.onNt(nt) 
                      (
                        to,
                        (nt.right, s66) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.escChars =>
                      val nt: NonTerminal = NonTerminal.AnonList5Head._2
                      val to = s66.onNt(nt) 
                      (
                        to,
                        (nt.right, s66) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`@mode:` =>
                      val nt: NonTerminal = NonTerminal.AnonList5Head._2
                      val to = s66.onNt(nt) 
                      (
                        to,
                        (nt.right, s66) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.AnonList5Head._2
                      val to = s66.onNt(nt) 
                      (
                        to,
                        (nt.right, s66) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.AnonList5Head._2
                      val to = s66.onNt(nt) 
                      (
                        to,
                        (nt.right, s66) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.char =>
                      val nt: NonTerminal = NonTerminal.AnonList5Head._2
                      val to = s66.onNt(nt) 
                      (
                        to,
                        (nt.right, s66) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`>>` =>
                      val nt: NonTerminal = NonTerminal.AnonList5Head._2
                      val to = s66.onNt(nt) 
                      (
                        to,
                        (nt.right, s66) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  val nt: NonTerminal = NonTerminal.AnonList5Head._2
                  val to = s66.onNt(nt) 
                  (
                    to,
                    (nt.right, s66) :: stack,
                    None,
                  ).left.some
              }
            },
            {
              case _: NonTerminal.Raw =>
                s18
              case _: NonTerminal.AnonList5Head =>
                s98
              case _: NonTerminal.Yield =>
                s13
              case _: NonTerminal.YieldType =>
                s91
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s67 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            67,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s23,
                        (tok.left, s67) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s27,
                        (tok.left, s67) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`[` =>
                      (
                        s4,
                        (tok.left, s67) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.escChars =>
                      (
                        s35,
                        (tok.left, s67) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`@mode:` =>
                      val nt: NonTerminal = NonTerminal.AnonList4Tail._2
                      val to = s67.onNt(nt) 
                      (
                        to,
                        (nt.right, s67) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.SequenceSimple._2
                      val to = s67.onNt(nt) 
                      (
                        to,
                        (nt.right, s67) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.SequenceSimple._2
                      val to = s67.onNt(nt) 
                      (
                        to,
                        (nt.right, s67) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.char =>
                      (
                        s92,
                        (tok.left, s67) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  val nt: NonTerminal = NonTerminal.AnonList4Tail._2
                  val to = s67.onNt(nt) 
                  (
                    to,
                    (nt.right, s67) :: stack,
                    None,
                  ).left.some
              }
            },
            {
              case _: NonTerminal.GroupInnerHead =>
                s51
              case _: NonTerminal.CharClass =>
                s53
              case _: NonTerminal.Regex =>
                s19
              case _: NonTerminal.AnonList4Tail =>
                s97
              case _: NonTerminal.SequenceSimple =>
                s12
              case _: NonTerminal.Group =>
                s3
              case _: NonTerminal.Line =>
                s11
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s68 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            68,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      stack match {
                        case (Right(_2: NonTerminal.SubString), _) :: (Right(_1: NonTerminal.YieldType), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Yield(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`,` =>
                      stack match {
                        case (Right(_2: NonTerminal.SubString), _) :: (Right(_1: NonTerminal.YieldType), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Yield(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.SubString), _) :: (Right(_1: NonTerminal.YieldType), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Yield(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`<-` =>
                      stack match {
                        case (Right(_2: NonTerminal.SubString), _) :: (Right(_1: NonTerminal.YieldType), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Yield(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Right(_2: NonTerminal.SubString), _) :: (Right(_1: NonTerminal.YieldType), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Yield(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`->` =>
                      stack match {
                        case (Right(_2: NonTerminal.SubString), _) :: (Right(_1: NonTerminal.YieldType), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Yield(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Right(_2: NonTerminal.SubString), _) :: (Right(_1: NonTerminal.YieldType), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Yield(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`@mode:` =>
                      stack match {
                        case (Right(_2: NonTerminal.SubString), _) :: (Right(_1: NonTerminal.YieldType), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Yield(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.SubString), _) :: (Right(_1: NonTerminal.YieldType), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Yield(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_2: NonTerminal.SubString), _) :: (Right(_1: NonTerminal.YieldType), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Yield(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Right(_2: NonTerminal.SubString), _) :: (Right(_1: NonTerminal.YieldType), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Yield(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`>>` =>
                      stack match {
                        case (Right(_2: NonTerminal.SubString), _) :: (Right(_1: NonTerminal.YieldType), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Yield(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  stack match {
                    case (Right(_2: NonTerminal.SubString), _) :: (Right(_1: NonTerminal.YieldType), poppedState) :: stack =>
                      val nt: NonTerminal = NonTerminal.Yield(_1, _2)
                      val to = poppedState.onNt(nt)
                      (
                        to,
                        (nt.right, poppedState) :: stack,
                        None,
                      ).left.some
                    case _ =>
                      None
                  }
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s69 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            69,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_5: Tok.`]`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SubString._2(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`,` =>
                      stack match {
                        case (Left(_5: Tok.`]`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SubString._2(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_5: Tok.`]`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SubString._2(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`<-` =>
                      stack match {
                        case (Left(_5: Tok.`]`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SubString._2(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_5: Tok.`]`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SubString._2(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`->` =>
                      stack match {
                        case (Left(_5: Tok.`]`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SubString._2(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_5: Tok.`]`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SubString._2(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`@mode:` =>
                      stack match {
                        case (Left(_5: Tok.`]`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SubString._2(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_5: Tok.`]`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SubString._2(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_5: Tok.`]`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SubString._2(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_5: Tok.`]`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SubString._2(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`>>` =>
                      stack match {
                        case (Left(_5: Tok.`]`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SubString._2(_1, _2, _3, _4, _5)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  stack match {
                    case (Left(_5: Tok.`]`), _) :: (Right(_4: NonTerminal.Opt_int), _) :: (Left(_3: Tok.`,`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                      val nt: NonTerminal = NonTerminal.SubString._2(_1, _2, _3, _4, _5)
                      val to = poppedState.onNt(nt)
                      (
                        to,
                        (nt.right, poppedState) :: stack,
                        None,
                      ).left.some
                    case _ =>
                      None
                  }
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s70 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            70,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`]` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList10Tail), _) :: (Right(_1: NonTerminal.CCChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList10Tail._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s71 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            71,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`]` =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChar._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChar._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChar._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChar._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s72 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            72,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.chars =>
                      (
                        s77,
                        (tok.left, s72) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.escChar =>
                      (
                        s60,
                        (tok.left, s72) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.AnonList7Head =>
                s110
              case _: NonTerminal.Char =>
                s9
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s73 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            73,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`}` =>
                      (
                        s36,
                        (tok.left, s73) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s74 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            74,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`*` =>
                      stack match {
                        case (Right(_2: NonTerminal.Quant), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._3(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Right(_2: NonTerminal.Quant), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._3(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Right(_2: NonTerminal.Quant), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._3(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.Quant), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._3(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Right(_2: NonTerminal.Quant), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._3(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Right(_2: NonTerminal.Quant), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._3(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Right(_2: NonTerminal.Quant), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._3(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.Quant), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._3(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_2: NonTerminal.Quant), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._3(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Right(_2: NonTerminal.Quant), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._3(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_2: NonTerminal.Quant), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._3(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s75 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            75,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      val nt: NonTerminal = NonTerminal.SequenceSimple._2
                      val to = s75.onNt(nt) 
                      (
                        to,
                        (nt.right, s75) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`*` =>
                      (
                        s63,
                        (tok.left, s75) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.escChar =>
                      (
                        s10,
                        (tok.left, s75) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`+` =>
                      (
                        s14,
                        (tok.left, s75) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s82,
                        (tok.left, s75) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`{` =>
                      (
                        s119,
                        (tok.left, s75) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`[` =>
                      (
                        s100,
                        (tok.left, s75) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.escChars =>
                      (
                        s124,
                        (tok.left, s75) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.SequenceSimple._2
                      val to = s75.onNt(nt) 
                      (
                        to,
                        (nt.right, s75) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.char =>
                      (
                        s78,
                        (tok.left, s75) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`?` =>
                      (
                        s80,
                        (tok.left, s75) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.CharClass =>
                s6
              case _: NonTerminal.Regex =>
                s75
              case _: NonTerminal.SequenceSimple =>
                s102
              case _: NonTerminal.Group =>
                s106
              case _: NonTerminal.Quant =>
                s87
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s76 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            76,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_1: Tok.`@`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.YieldType._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s77 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            77,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.chars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Char._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.chars =>
                      stack match {
                        case (Left(_1: Tok.chars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Char._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_1: Tok.chars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Char._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s78 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            78,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`*` =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s79 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            79,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList6Tail), _) :: (Right(_1: NonTerminal.Yield), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList5Head._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList6Tail), _) :: (Right(_1: NonTerminal.Yield), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList5Head._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`<-` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList6Tail), _) :: (Right(_1: NonTerminal.Yield), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList5Head._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList6Tail), _) :: (Right(_1: NonTerminal.Yield), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList5Head._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`->` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList6Tail), _) :: (Right(_1: NonTerminal.Yield), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList5Head._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList6Tail), _) :: (Right(_1: NonTerminal.Yield), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList5Head._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`@mode:` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList6Tail), _) :: (Right(_1: NonTerminal.Yield), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList5Head._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList6Tail), _) :: (Right(_1: NonTerminal.Yield), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList5Head._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList6Tail), _) :: (Right(_1: NonTerminal.Yield), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList5Head._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList6Tail), _) :: (Right(_1: NonTerminal.Yield), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList5Head._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`>>` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList6Tail), _) :: (Right(_1: NonTerminal.Yield), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList5Head._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  stack match {
                    case (Right(_2: NonTerminal.AnonList6Tail), _) :: (Right(_1: NonTerminal.Yield), poppedState) :: stack =>
                      val nt: NonTerminal = NonTerminal.AnonList5Head._1(_1, _2)
                      val to = poppedState.onNt(nt)
                      (
                        to,
                        (nt.right, poppedState) :: stack,
                        None,
                      ).left.some
                    case _ =>
                      None
                  }
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s80 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            80,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`*` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s81 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            81,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`@mode:` =>
                      stack match {
                        case (Right(_3: NonTerminal.AnonList3Head), _) :: (Left(_2: Tok.mode), _) :: (Left(_1: Tok.`@mode:`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Mode(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  stack match {
                    case (Right(_3: NonTerminal.AnonList3Head), _) :: (Left(_2: Tok.mode), _) :: (Left(_1: Tok.`@mode:`), poppedState) :: stack =>
                      val nt: NonTerminal = NonTerminal.Mode(_1, _2, _3)
                      val to = poppedState.onNt(nt)
                      (
                        to,
                        (nt.right, poppedState) :: stack,
                        None,
                      ).left.some
                    case _ =>
                      None
                  }
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s82 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            82,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      val nt: NonTerminal = NonTerminal.SequenceSimple._2
                      val to = s82.onNt(nt) 
                      (
                        to,
                        (nt.right, s82) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.escChar =>
                      (
                        s10,
                        (tok.left, s82) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s82,
                        (tok.left, s82) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`[` =>
                      (
                        s100,
                        (tok.left, s82) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.escChars =>
                      (
                        s124,
                        (tok.left, s82) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.SequenceSimple._2
                      val to = s82.onNt(nt) 
                      (
                        to,
                        (nt.right, s82) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.char =>
                      (
                        s78,
                        (tok.left, s82) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.GroupInnerHead =>
                s54
              case _: NonTerminal.CharClass =>
                s6
              case _: NonTerminal.Regex =>
                s75
              case _: NonTerminal.SequenceSimple =>
                s38
              case _: NonTerminal.Group =>
                s106
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s83 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            83,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok =>
                      None
                  }
                case None =>
                  stack match {
                    case (Right(ntRoot: NtRoot), _) :: Nil =>
                      ntRoot.right.some
                    case _ =>
                      None
                  }
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s84 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            84,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`*` =>
                      stack match {
                        case (Left(_1: Tok.`+`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_1: Tok.`+`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Left(_1: Tok.`+`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`+`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Left(_1: Tok.`+`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_1: Tok.`+`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_1: Tok.`+`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.`+`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.`+`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_1: Tok.`+`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.`+`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Quant._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s85 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            85,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`,` =>
                      (
                        s121,
                        (tok.left, s85) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`]` =>
                      (
                        s115,
                        (tok.left, s85) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s86 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            86,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`}` =>
                      (
                        s26,
                        (tok.left, s86) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`,` =>
                      (
                        s2,
                        (tok.left, s86) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s87 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            87,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_2: NonTerminal.Quant), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._3(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`*` =>
                      stack match {
                        case (Right(_2: NonTerminal.Quant), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._3(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Right(_2: NonTerminal.Quant), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._3(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Right(_2: NonTerminal.Quant), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._3(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.Quant), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._3(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Right(_2: NonTerminal.Quant), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._3(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Right(_2: NonTerminal.Quant), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._3(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Right(_2: NonTerminal.Quant), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._3(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_2: NonTerminal.Quant), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._3(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Right(_2: NonTerminal.Quant), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._3(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_2: NonTerminal.Quant), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._3(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s88 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            88,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChars =>
                      (
                        s101,
                        (tok.left, s88) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.escChar =>
                      (
                        s116,
                        (tok.left, s88) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.char =>
                      (
                        s104,
                        (tok.left, s88) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`]` =>
                      val nt: NonTerminal = NonTerminal.AnonList10Tail._2
                      val to = s88.onNt(nt) 
                      (
                        to,
                        (nt.right, s88) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.AnonList10Tail =>
                s70
              case _: NonTerminal.CCChars =>
                s88
              case _: NonTerminal.CCChar =>
                s56
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s89 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            89,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`@` =>
                      (
                        s76,
                        (tok.left, s89) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s72,
                        (tok.left, s89) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.term =>
                      (
                        s16,
                        (tok.left, s89) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Raw =>
                s18
              case _: NonTerminal.Yield =>
                s103
              case _: NonTerminal.YieldType =>
                s91
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s90 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            90,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChars =>
                      (
                        s101,
                        (tok.left, s90) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.escChar =>
                      (
                        s116,
                        (tok.left, s90) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.char =>
                      (
                        s104,
                        (tok.left, s90) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.AnonList9Head =>
                s93
              case _: NonTerminal.CCChars =>
                s50
              case _: NonTerminal.CCChar =>
                s56
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s91 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            91,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`[` =>
                      (
                        s125,
                        (tok.left, s91) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.SubString =>
                s68
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s92 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            92,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`*` =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s93 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            93,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`]` =>
                      (
                        s24,
                        (tok.left, s93) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s94 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            94,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList7Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s95 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            95,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.mode =>
                      (
                        s20,
                        (tok.left, s95) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s96 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            96,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s23,
                        (tok.left, s96) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s27,
                        (tok.left, s96) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`[` =>
                      (
                        s4,
                        (tok.left, s96) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.escChars =>
                      (
                        s35,
                        (tok.left, s96) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.SequenceSimple._2
                      val to = s96.onNt(nt) 
                      (
                        to,
                        (nt.right, s96) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.SequenceSimple._2
                      val to = s96.onNt(nt) 
                      (
                        to,
                        (nt.right, s96) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.char =>
                      (
                        s92,
                        (tok.left, s96) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.CharClass =>
                s53
              case _: NonTerminal.Regex =>
                s19
              case _: NonTerminal.SequenceSimple =>
                s105
              case _: NonTerminal.Group =>
                s3
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s97 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            97,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`@mode:` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList4Tail), _) :: (Right(_1: NonTerminal.Line), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList3Head(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  stack match {
                    case (Right(_2: NonTerminal.AnonList4Tail), _) :: (Right(_1: NonTerminal.Line), poppedState) :: stack =>
                      val nt: NonTerminal = NonTerminal.AnonList3Head(_1, _2)
                      val to = poppedState.onNt(nt)
                      (
                        to,
                        (nt.right, poppedState) :: stack,
                        None,
                      ).left.some
                    case _ =>
                      None
                  }
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s98 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            98,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      val nt: NonTerminal = NonTerminal.OptToMode._2
                      val to = s98.onNt(nt) 
                      (
                        to,
                        (nt.right, s98) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.OptToMode._2
                      val to = s98.onNt(nt) 
                      (
                        to,
                        (nt.right, s98) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`<-` =>
                      (
                        s59,
                        (tok.left, s98) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`[` =>
                      val nt: NonTerminal = NonTerminal.OptToMode._2
                      val to = s98.onNt(nt) 
                      (
                        to,
                        (nt.right, s98) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`->` =>
                      (
                        s29,
                        (tok.left, s98) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.escChars =>
                      val nt: NonTerminal = NonTerminal.OptToMode._2
                      val to = s98.onNt(nt) 
                      (
                        to,
                        (nt.right, s98) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`@mode:` =>
                      val nt: NonTerminal = NonTerminal.OptToMode._2
                      val to = s98.onNt(nt) 
                      (
                        to,
                        (nt.right, s98) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.OptToMode._2
                      val to = s98.onNt(nt) 
                      (
                        to,
                        (nt.right, s98) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.OptToMode._2
                      val to = s98.onNt(nt) 
                      (
                        to,
                        (nt.right, s98) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.char =>
                      val nt: NonTerminal = NonTerminal.OptToMode._2
                      val to = s98.onNt(nt) 
                      (
                        to,
                        (nt.right, s98) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`>>` =>
                      (
                        s49,
                        (tok.left, s98) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  val nt: NonTerminal = NonTerminal.OptToMode._2
                  val to = s98.onNt(nt) 
                  (
                    to,
                    (nt.right, s98) :: stack,
                    None,
                  ).left.some
              }
            },
            {
              case _: NonTerminal.OptToMode =>
                s25
              case _: NonTerminal.ToMode =>
                s8
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s99 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            99,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_3: NonTerminal.GroupInnerTail), _) :: (Right(_2: NonTerminal.SequenceSimple), _) :: (Left(_1: Tok.`|`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.GroupInnerTail._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s100 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            100,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`^` =>
                      (
                        s123,
                        (tok.left, s100) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.escChars =>
                      val nt: NonTerminal = NonTerminal.`Opt_^`._2
                      val to = s100.onNt(nt) 
                      (
                        to,
                        (nt.right, s100) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.char =>
                      val nt: NonTerminal = NonTerminal.`Opt_^`._2
                      val to = s100.onNt(nt) 
                      (
                        to,
                        (nt.right, s100) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.escChar =>
                      val nt: NonTerminal = NonTerminal.`Opt_^`._2
                      val to = s100.onNt(nt) 
                      (
                        to,
                        (nt.right, s100) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.`Opt_^` =>
                s39
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s101 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            101,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`]` =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChars._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChars._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChars._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChars._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s102 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            102,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_2: NonTerminal.SequenceSimple), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SequenceSimple._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_2: NonTerminal.SequenceSimple), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SequenceSimple._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s103 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            103,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      val to = s103.onNt(nt) 
                      (
                        to,
                        (nt.right, s103) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`,` =>
                      (
                        s89,
                        (tok.left, s103) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      val to = s103.onNt(nt) 
                      (
                        to,
                        (nt.right, s103) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`<-` =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      val to = s103.onNt(nt) 
                      (
                        to,
                        (nt.right, s103) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`[` =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      val to = s103.onNt(nt) 
                      (
                        to,
                        (nt.right, s103) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`->` =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      val to = s103.onNt(nt) 
                      (
                        to,
                        (nt.right, s103) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.escChars =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      val to = s103.onNt(nt) 
                      (
                        to,
                        (nt.right, s103) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`@mode:` =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      val to = s103.onNt(nt) 
                      (
                        to,
                        (nt.right, s103) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      val to = s103.onNt(nt) 
                      (
                        to,
                        (nt.right, s103) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      val to = s103.onNt(nt) 
                      (
                        to,
                        (nt.right, s103) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.char =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      val to = s103.onNt(nt) 
                      (
                        to,
                        (nt.right, s103) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`>>` =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      val to = s103.onNt(nt) 
                      (
                        to,
                        (nt.right, s103) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                  val to = s103.onNt(nt) 
                  (
                    to,
                    (nt.right, s103) :: stack,
                    None,
                  ).left.some
              }
            },
            {
              case _: NonTerminal.AnonList6Tail =>
                s43
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s104 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            104,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChar._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`-` =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChar._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`]` =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChar._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChar._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_1: Tok.char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChar._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s105 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            105,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`|` =>
                      (
                        s96,
                        (tok.left, s105) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.GroupInnerTail._2
                      val to = s105.onNt(nt) 
                      (
                        to,
                        (nt.right, s105) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.GroupInnerTail =>
                s99
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s106 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            106,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_1: NonTerminal.Group), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`*` =>
                      stack match {
                        case (Right(_1: NonTerminal.Group), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Right(_1: NonTerminal.Group), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Right(_1: NonTerminal.Group), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.Group), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Right(_1: NonTerminal.Group), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Right(_1: NonTerminal.Group), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Right(_1: NonTerminal.Group), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_1: NonTerminal.Group), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Right(_1: NonTerminal.Group), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Group), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Regex._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s107 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            107,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`]` =>
                      (
                        s69,
                        (tok.left, s107) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s108 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            108,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.SequenceSimple), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SequenceSimple._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_2: NonTerminal.SequenceSimple), _) :: (Right(_1: NonTerminal.Regex), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SequenceSimple._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s109 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            109,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`}` =>
                      stack match {
                        case (Left(_1: Tok.int), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Opt_int._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s110 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            110,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      (
                        s94,
                        (tok.left, s110) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s111 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            111,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_3: NonTerminal.GroupInnerTail), _) :: (Right(_2: NonTerminal.SequenceSimple), _) :: (Left(_1: Tok.`|`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.GroupInnerTail._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s112 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            112,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`]` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList10Tail), _) :: (Right(_1: NonTerminal.CCChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList9Head(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s113 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            113,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`@mode:` =>
                      (
                        s0,
                        (tok.left, s113) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  val nt: NonTerminal = NonTerminal.AnonList2Tail._2
                  val to = s113.onNt(nt) 
                  (
                    to,
                    (nt.right, s113) :: stack,
                    None,
                  ).left.some
              }
            },
            {
              case _: NonTerminal.AnonList2Tail =>
                s46
              case _: NonTerminal.Mode =>
                s37
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s114 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            114,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`@mode:` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList4Tail), _) :: (Right(_1: NonTerminal.Line), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList4Tail._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  stack match {
                    case (Right(_2: NonTerminal.AnonList4Tail), _) :: (Right(_1: NonTerminal.Line), poppedState) :: stack =>
                      val nt: NonTerminal = NonTerminal.AnonList4Tail._1(_1, _2)
                      val to = poppedState.onNt(nt)
                      (
                        to,
                        (nt.right, poppedState) :: stack,
                        None,
                      ).left.some
                    case _ =>
                      None
                  }
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s115 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            115,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_3: Tok.`]`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SubString._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`,` =>
                      stack match {
                        case (Left(_3: Tok.`]`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SubString._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`]`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SubString._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`<-` =>
                      stack match {
                        case (Left(_3: Tok.`]`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SubString._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_3: Tok.`]`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SubString._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`->` =>
                      stack match {
                        case (Left(_3: Tok.`]`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SubString._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_3: Tok.`]`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SubString._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`@mode:` =>
                      stack match {
                        case (Left(_3: Tok.`]`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SubString._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_3: Tok.`]`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SubString._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_3: Tok.`]`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SubString._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_3: Tok.`]`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SubString._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`>>` =>
                      stack match {
                        case (Left(_3: Tok.`]`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.SubString._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  stack match {
                    case (Left(_3: Tok.`]`), _) :: (Right(_2: NonTerminal.Opt_int), _) :: (Left(_1: Tok.`[`), poppedState) :: stack =>
                      val nt: NonTerminal = NonTerminal.SubString._1(_1, _2, _3)
                      val to = poppedState.onNt(nt)
                      (
                        to,
                        (nt.right, poppedState) :: stack,
                        None,
                      ).left.some
                    case _ =>
                      None
                  }
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s116 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            116,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChar._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`-` =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChar._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`]` =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChar._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChar._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CCChar._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s117 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            117,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`}` =>
                      (
                        s65,
                        (tok.left, s117) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`,` =>
                      (
                        s31,
                        (tok.left, s117) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s118 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            118,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_2: Tok.mode), _) :: (Left(_1: Tok.`->`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ToMode._2(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_2: Tok.mode), _) :: (Left(_1: Tok.`->`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ToMode._2(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_2: Tok.mode), _) :: (Left(_1: Tok.`->`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ToMode._2(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_2: Tok.mode), _) :: (Left(_1: Tok.`->`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ToMode._2(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`@mode:` =>
                      stack match {
                        case (Left(_2: Tok.mode), _) :: (Left(_1: Tok.`->`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ToMode._2(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_2: Tok.mode), _) :: (Left(_1: Tok.`->`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ToMode._2(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_2: Tok.mode), _) :: (Left(_1: Tok.`->`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ToMode._2(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_2: Tok.mode), _) :: (Left(_1: Tok.`->`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ToMode._2(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  stack match {
                    case (Left(_2: Tok.mode), _) :: (Left(_1: Tok.`->`), poppedState) :: stack =>
                      val nt: NonTerminal = NonTerminal.ToMode._2(_1, _2)
                      val to = poppedState.onNt(nt)
                      (
                        to,
                        (nt.right, poppedState) :: stack,
                        None,
                      ).left.some
                    case _ =>
                      None
                  }
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s119 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            119,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.int =>
                      (
                        s64,
                        (tok.left, s119) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`,` =>
                      val nt: NonTerminal = NonTerminal.Opt_int._2
                      val to = s119.onNt(nt) 
                      (
                        to,
                        (nt.right, s119) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`}` =>
                      val nt: NonTerminal = NonTerminal.Opt_int._2
                      val to = s119.onNt(nt) 
                      (
                        to,
                        (nt.right, s119) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Opt_int =>
                s117
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s120 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            120,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok =>
                      None
                  }
                case None =>
                  stack match {
                    case (Right(_3: NonTerminal.AnonList1Head), _) :: (Left(_2: Tok.mode), _) :: (Left(_1: Tok.`@start:`), poppedState) :: stack =>
                      val nt: NonTerminal = NonTerminal.Lexer(_1, _2, _3)
                      val to = poppedState.onNt(nt)
                      (
                        to,
                        (nt.right, poppedState) :: stack,
                        None,
                      ).left.some
                    case _ =>
                      None
                  }
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s121 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            121,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.int =>
                      (
                        s48,
                        (tok.left, s121) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`]` =>
                      val nt: NonTerminal = NonTerminal.Opt_int._2
                      val to = s121.onNt(nt) 
                      (
                        to,
                        (nt.right, s121) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Opt_int =>
                s107
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s122 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            122,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.GroupInnerHead), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Group(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`*` =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.GroupInnerHead), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Group(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.GroupInnerHead), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Group(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.GroupInnerHead), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Group(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.GroupInnerHead), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Group(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.GroupInnerHead), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Group(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.GroupInnerHead), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Group(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.GroupInnerHead), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Group(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.GroupInnerHead), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Group(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.GroupInnerHead), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Group(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.GroupInnerHead), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Group(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s123 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            123,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_1: Tok.`^`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_^`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_1: Tok.`^`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_^`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_1: Tok.`^`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_^`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s124 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            124,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`*` =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`+` =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`{` =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`[` =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.escChars =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.char =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.escChars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.CharClass._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s125 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            125,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.int =>
                      (
                        s44,
                        (tok.left, s125) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`,` =>
                      val nt: NonTerminal = NonTerminal.Opt_int._2
                      val to = s125.onNt(nt) 
                      (
                        to,
                        (nt.right, s125) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`]` =>
                      val nt: NonTerminal = NonTerminal.Opt_int._2
                      val to = s125.onNt(nt) 
                      (
                        to,
                        (nt.right, s125) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Opt_int =>
                s85
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s55
      },
    )
  
}
// format: on
