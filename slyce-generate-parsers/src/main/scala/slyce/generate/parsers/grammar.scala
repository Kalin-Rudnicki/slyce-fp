// !!! DO NOT MODIFY !!!
// File was automatically generated by slyce v0.1.0

package slyce.generate.parsers

// format: off

import scala.annotation.tailrec

import klib.Implicits._
import klib.fp.types._
import klib.utils._

import slyce.core._
import slyce.parse._

object grammar {
  
  sealed abstract class Tok(val tokName: String) extends Token
  object Tok {
    final case class assocType(text: String, span: Span.Highlight) extends Tok("assocType")
    final case class chars(text: String, span: Span.Highlight) extends Tok("chars") with NonTerminal.Char.LiftType
    final case class escChar(text: String, span: Span.Highlight) extends Tok("escChar") with NonTerminal.Char.LiftType
    final case class listType(text: String, span: Span.Highlight) extends Tok("listType")
    final case class mode(text: String, span: Span.Highlight) extends Tok("mode")
    final case class nonTerminal(text: String, span: Span.Highlight) extends Tok("nonTerminal") with NonTerminal.NonOptElement.LiftType
    final case class terminal(text: String, span: Span.Highlight) extends Tok("terminal") with NonTerminal.NonOptElement.LiftType
    final case class tilde(text: String, span: Span.Highlight) extends Tok("tilde")
    
    final case class `(`(text: String, span: Span.Highlight) extends Tok(""""("""")
    final case class `)`(text: String, span: Span.Highlight) extends Tok("""")"""")
    final case class `.`(text: String, span: Span.Highlight) extends Tok(""""."""")
    final case class `:`(text: String, span: Span.Highlight) extends Tok("""":"""")
    final case class `;`(text: String, span: Span.Highlight) extends Tok("""";"""")
    final case class `?`(text: String, span: Span.Highlight) extends Tok(""""?"""")
    final case class `@start:`(text: String, span: Span.Highlight) extends Tok(""""@start:"""")
    final case class `\"`(text: String, span: Span.Highlight) extends Tok(""""\""""")
    final case class `^`(text: String, span: Span.Highlight) extends Tok(""""^"""")
    final case class `|`(text: String, span: Span.Highlight) extends Tok(""""|"""")
    
    def findRawTerminal(text: String, span: Span.Highlight): Attempt[Tok] =
      text match {
        case "(" => Tok.`(`(text, span).pure[Attempt]
        case ")" => Tok.`)`(text, span).pure[Attempt]
        case "." => Tok.`.`(text, span).pure[Attempt]
        case ":" => Tok.`:`(text, span).pure[Attempt]
        case ";" => Tok.`;`(text, span).pure[Attempt]
        case "?" => Tok.`?`(text, span).pure[Attempt]
        case "@start:" => Tok.`@start:`(text, span).pure[Attempt]
        case "\"" => Tok.`\"`(text, span).pure[Attempt]
        case "^" => Tok.`^`(text, span).pure[Attempt]
        case "|" => Tok.`|`(text, span).pure[Attempt]
        case _ => Dead(Marked(s"Invalid raw-terminal : ${text.unesc}", span) :: Nil)
      }
  }
  
  type NtRoot = NonTerminal.Grammar
  sealed trait NonTerminal
  object NonTerminal {
    type ElementList = ElementListSimple
    
    sealed trait AnonList extends NonTerminal with NonTerminal.NonOptElement.LiftType
    object AnonList {
      final case class _1(
        _0: NonTerminal.Element,
        _1: Tok.listType,
      ) extends AnonList
      final case class _2(
        _0: Tok.`(`,
        _1: NonTerminal.UnIgnoredElementList,
        _2: Tok.`)`,
        _3: Tok.listType,
      ) extends AnonList
      final case class _3(
        _0: Tok.`(`,
        _1: NonTerminal.UnIgnoredElementList,
        _2: Tok.`.`,
        _3: NonTerminal.UnIgnoredElementList,
        _4: Tok.`)`,
        _5: Tok.listType,
      ) extends AnonList
    }
    
    sealed trait AnonList10Tail extends NonTerminal
    object AnonList10Tail {
      final case class _1(
        _0: NonTerminal.Char,
        _1: NonTerminal.AnonList10Tail,
      ) extends AnonList10Tail
      case object _2 extends AnonList10Tail
    }
    
    final case class AnonList1Head(
      _0: NonTerminal.NT,
      _1: Tok.`;`,
      _2: NonTerminal.AnonList2Tail,
    ) extends NonTerminal {
      
      def toNonEmptyList: NonEmptyList[AnonList1Head.LiftType] = {
        @tailrec
        def loop(queue: AnonList2Tail, stack: List[AnonList1Head.LiftType]): List[AnonList1Head.LiftType] =
          queue match {
            case head: AnonList2Tail._1 => loop(head._2, head._0 :: stack)
            case _: AnonList2Tail._2.type => stack.reverse
          }
        
        NonEmptyList[AnonList1Head.LiftType](this._0, loop(this._2, Nil))
      }
      
    }
    object AnonList1Head {
      type LiftType = NonTerminal.NT
    }
    
    sealed trait AnonList2Tail extends NonTerminal
    object AnonList2Tail {
      final case class _1(
        _0: NonTerminal.NT,
        _1: Tok.`;`,
        _2: NonTerminal.AnonList2Tail,
      ) extends AnonList2Tail
      case object _2 extends AnonList2Tail
    }
    
    final case class AnonList3Head(
      _0: NonTerminal.ElementListSimple,
      _1: NonTerminal.AnonList4Tail,
    ) extends NonTerminal {
      
      def toNonEmptyList: NonEmptyList[AnonList3Head.LiftType] = {
        @tailrec
        def loop(queue: AnonList4Tail, stack: List[AnonList3Head.LiftType]): List[AnonList3Head.LiftType] =
          queue match {
            case head: AnonList4Tail._1 => loop(head._2, head._1 :: stack)
            case _: AnonList4Tail._2.type => stack.reverse
          }
        
        NonEmptyList[AnonList3Head.LiftType](this._0, loop(this._1, Nil))
      }
      
    }
    object AnonList3Head {
      type LiftType = NonTerminal.ElementList
    }
    
    sealed trait AnonList4Tail extends NonTerminal
    object AnonList4Tail {
      final case class _1(
        _0: Tok.`|`,
        _1: NonTerminal.ElementListSimple,
        _2: NonTerminal.AnonList4Tail,
      ) extends AnonList4Tail
      case object _2 extends AnonList4Tail
    }
    
    final case class AnonList5Head(
      _0: NonTerminal.UnIgnoredElementList,
      _1: NonTerminal.AnonList6Tail,
    ) extends NonTerminal {
      
      def toNonEmptyList: NonEmptyList[AnonList5Head.LiftType] = {
        @tailrec
        def loop(queue: AnonList6Tail, stack: List[AnonList5Head.LiftType]): List[AnonList5Head.LiftType] =
          queue match {
            case head: AnonList6Tail._1 => loop(head._2, head._1 :: stack)
            case _: AnonList6Tail._2.type => stack.reverse
          }
        
        NonEmptyList[AnonList5Head.LiftType](this._0, loop(this._1, Nil))
      }
      
    }
    object AnonList5Head {
      type LiftType = NonTerminal.UnIgnoredElementList
    }
    
    sealed trait AnonList6Tail extends NonTerminal
    object AnonList6Tail {
      final case class _1(
        _0: Tok.`|`,
        _1: NonTerminal.UnIgnoredElementList,
        _2: NonTerminal.AnonList6Tail,
      ) extends AnonList6Tail
      case object _2 extends AnonList6Tail
    }
    
    final case class AnonList7Head(
      _0: NonTerminal.AssocPair,
      _1: NonTerminal.AnonList8Tail,
    ) extends NonTerminal {
      
      def toNonEmptyList: NonEmptyList[AnonList7Head.LiftType] = {
        @tailrec
        def loop(queue: AnonList8Tail, stack: List[AnonList7Head.LiftType]): List[AnonList7Head.LiftType] =
          queue match {
            case head: AnonList8Tail._1 => loop(head._2, head._1 :: stack)
            case _: AnonList8Tail._2.type => stack.reverse
          }
        
        NonEmptyList[AnonList7Head.LiftType](this._0, loop(this._1, Nil))
      }
      
    }
    object AnonList7Head {
      type LiftType = NonTerminal.AssocPair
    }
    
    sealed trait AnonList8Tail extends NonTerminal
    object AnonList8Tail {
      final case class _1(
        _0: Tok.`|`,
        _1: NonTerminal.AssocPair,
        _2: NonTerminal.AnonList8Tail,
      ) extends AnonList8Tail
      case object _2 extends AnonList8Tail
    }
    
    final case class AnonList9Head(
      _0: NonTerminal.Char,
      _1: NonTerminal.AnonList10Tail,
    ) extends NonTerminal {
      
      def toNonEmptyList: NonEmptyList[AnonList9Head.LiftType] = {
        @tailrec
        def loop(queue: AnonList10Tail, stack: List[AnonList9Head.LiftType]): List[AnonList9Head.LiftType] =
          queue match {
            case head: AnonList10Tail._1 => loop(head._1, head._0 :: stack)
            case _: AnonList10Tail._2.type => stack.reverse
          }
        
        NonEmptyList[AnonList9Head.LiftType](this._0, loop(this._1, Nil))
      }
      
    }
    object AnonList9Head {
      type LiftType = NonTerminal.Char
    }
    
    final case class AssocNT(
      _0: Tok.tilde,
      _1: NonTerminal.AnonList7Head,
      _2: NonTerminal.StandardNT,
    ) extends NonTerminal with NonTerminal.NTBody.LiftType
    
    final case class AssocPair(
      _0: Tok.assocType,
      _1: NonTerminal.Element,
    ) extends NonTerminal
    
    final case class BasicNT(
      _0: Tok.`:`,
      _1: NonTerminal.AnonList3Head,
    ) extends NonTerminal with NonTerminal.StandardNT.LiftType
    
    sealed trait Char extends NonTerminal {
      
      def lift: Char.LiftType =
        this match {
          case nt: Char._1 => nt._0
          case nt: Char._2 => nt._0
        }
      
    }
    object Char {
      sealed trait LiftType
      
      final case class _1(
        _0: Tok.chars,
      ) extends Char
      final case class _2(
        _0: Tok.escChar,
      ) extends Char
    }
    
    final case class Element(
      _0: NonTerminal.NonOptElement,
      _1: NonTerminal.`Opt_?`,
    ) extends NonTerminal
    
    sealed trait ElementListSimple extends NonTerminal {
      
      def toList: List[ElementListSimple.LiftType] = {
        @tailrec
        def loop(queue: ElementListSimple, stack: List[ElementListSimple.LiftType]): List[ElementListSimple.LiftType] =
          queue match {
            case head: ElementListSimple._1 => loop(head._1, head._0 :: stack)
            case _: ElementListSimple._2.type => stack.reverse
          }
        
        loop(this, Nil)
      }
      
    }
    object ElementListSimple {
      type LiftType = NonTerminal.Element
      
      final case class _1(
        _0: NonTerminal.Element,
        _1: NonTerminal.ElementListSimple,
      ) extends ElementListSimple
      case object _2 extends ElementListSimple
    }
    
    final case class Grammar(
      _0: Tok.`@start:`,
      _1: Tok.mode,
      _2: NonTerminal.AnonList1Head,
    ) extends NonTerminal
    
    final case class LiftNT(
      _0: Tok.`^`,
      _1: NonTerminal.AnonList5Head,
    ) extends NonTerminal with NonTerminal.StandardNT.LiftType
    
    sealed trait ListNT extends NonTerminal with NonTerminal.NTBody.LiftType
    object ListNT {
      final case class _1(
        _0: Tok.listType,
        _1: NonTerminal.UnIgnoredElementList,
      ) extends ListNT
      final case class _2(
        _0: Tok.listType,
        _1: NonTerminal.UnIgnoredElementList,
        _2: Tok.`.`,
        _3: NonTerminal.UnIgnoredElementList,
      ) extends ListNT
    }
    
    final case class NT(
      _0: Tok.nonTerminal,
      _1: NonTerminal.NTBody,
    ) extends NonTerminal
    
    sealed trait NTBody extends NonTerminal {
      
      def lift: NTBody.LiftType =
        this match {
          case nt: NTBody._1 => nt._0
          case nt: NTBody._2 => nt._0
          case nt: NTBody._3 => nt._0
        }
      
    }
    object NTBody {
      sealed trait LiftType
      
      final case class _1(
        _0: NonTerminal.StandardNT,
      ) extends NTBody
      final case class _2(
        _0: NonTerminal.ListNT,
      ) extends NTBody
      final case class _3(
        _0: NonTerminal.AssocNT,
      ) extends NTBody
    }
    
    sealed trait NonOptElement extends NonTerminal {
      
      def lift: NonOptElement.LiftType =
        this match {
          case nt: NonOptElement._1 => nt._0
          case nt: NonOptElement._2 => nt._0
          case nt: NonOptElement._3 => nt._0
          case nt: NonOptElement._4 => nt._0
        }
      
    }
    object NonOptElement {
      sealed trait LiftType
      
      final case class _1(
        _0: Tok.nonTerminal,
      ) extends NonOptElement
      final case class _2(
        _0: Tok.terminal,
      ) extends NonOptElement
      final case class _3(
        _0: NonTerminal.Raw,
      ) extends NonOptElement
      final case class _4(
        _0: NonTerminal.AnonList,
      ) extends NonOptElement
    }
    
    final case class Raw(
      _0: Tok.`\"`,
      _1: NonTerminal.AnonList9Head,
      _2: Tok.`\"`,
    ) extends NonTerminal with NonTerminal.NonOptElement.LiftType
    
    sealed trait StandardNT extends NonTerminal with NonTerminal.NTBody.LiftType {
      
      def lift: StandardNT.LiftType =
        this match {
          case nt: StandardNT._1 => nt._0
          case nt: StandardNT._2 => nt._0
        }
      
    }
    object StandardNT {
      sealed trait LiftType
      
      final case class _1(
        _0: NonTerminal.BasicNT,
      ) extends StandardNT
      final case class _2(
        _0: NonTerminal.LiftNT,
      ) extends StandardNT
    }
    
    sealed trait UnIgnoredElementList extends NonTerminal
    object UnIgnoredElementList {
      final case class _1(
        _0: NonTerminal.Element,
      ) extends UnIgnoredElementList
      final case class _2(
        _0: NonTerminal.ElementListSimple,
        _1: Tok.`^`,
        _2: NonTerminal.Element,
        _3: NonTerminal.ElementListSimple,
      ) extends UnIgnoredElementList
    }
    
    sealed trait `Opt_?` extends NonTerminal {
      
      def toMaybe: Maybe[`Opt_?`.LiftType] =
        this match {
          case `Opt_?`._1(some) => some.some
          case `Opt_?`._2 => None
        }
      
    }
    object `Opt_?` {
      type LiftType = Tok.`?`
      
      final case class _1(
        _0: Tok.`?`,
      ) extends `Opt_?`
      case object _2 extends `Opt_?`
    }
    
  }
  
  lazy val parser: Parser[Tok, NonTerminal, NtRoot] =
    Parser[Tok, NonTerminal, NtRoot](
      Lexer[Tok] {
        var s21: Lexer.State[Tok] = null
        var s0: Lexer.State[Tok] = null
        var s1: Lexer.State[Tok] = null
        var s2: Lexer.State[Tok] = null
        var s3: Lexer.State[Tok] = null
        var s4: Lexer.State[Tok] = null
        var s5: Lexer.State[Tok] = null
        var s6: Lexer.State[Tok] = null
        var s7: Lexer.State[Tok] = null
        var s8: Lexer.State[Tok] = null
        var s9: Lexer.State[Tok] = null
        var s10: Lexer.State[Tok] = null
        var s11: Lexer.State[Tok] = null
        var s12: Lexer.State[Tok] = null
        var s13: Lexer.State[Tok] = null
        var s14: Lexer.State[Tok] = null
        var s15: Lexer.State[Tok] = null
        var s16: Lexer.State[Tok] = null
        var s17: Lexer.State[Tok] = null
        var s18: Lexer.State[Tok] = null
        var s19: Lexer.State[Tok] = null
        var s20: Lexer.State[Tok] = null
        var s22: Lexer.State[Tok] = null
        var s23: Lexer.State[Tok] = null
        var s24: Lexer.State[Tok] = null
        var s25: Lexer.State[Tok] = null
        var s26: Lexer.State[Tok] = null
        var s27: Lexer.State[Tok] = null
        var s28: Lexer.State[Tok] = null
        var s29: Lexer.State[Tok] = null
        var s30: Lexer.State[Tok] = null
        
        s21 =
          Lexer.State[Tok](
            21,
            char => {
              val int = char.toInt
              
              if (int == 64) // '@'
                s9.some
              else if (int == 34) // '\"'
                s2.some
              else if (int >= 97 && int <= 122) // 'a'-'z'
                s17.some
              else if (int >= 40 && int <= 41) // '('-')'
                s25.some
              else if (int == 46) // '.'
                s25.some
              else if (int >= 58 && int <= 59) // ':'-';'
                s25.some
              else if (int == 63) // '?'
                s25.some
              else if (int == 94) // '^'
                s25.some
              else if (int == 124) // '|'
                s25.some
              else if (int == 60) // '<'
                s8.some
              else if (int == 62) // '>'
                s8.some
              else if (int == 126) // '~'
                s29.some
              else if (int == 47) // '/'
                s20.some
              else if (int >= 9 && int <= 10) // '\t'-'\n'
                s6.some
              else if (int == 32) // ' '
                s6.some
              else if (int >= 65 && int <= 90) // 'A'-'Z'
                s10.some
              else if (int >= 42 && int <= 43) // '*'-'+'
                s28.some
              else
                None
            },
            None,
          )
        
        s0 =
          Lexer.State[Tok](
            0,
            char => {
              val int = char.toInt
              
              if (int >= 48 && int <= 57) // '0'-'9'
                s0.some
              else if (int >= 65 && int <= 90) // 'A'-'Z'
                s0.some
              else if (int == 95) // '_'
                s0.some
              else if (int >= 97 && int <= 122) // 'a'-'z'
                s0.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.mode(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s1 =
          Lexer.State[Tok](
            1,
            char => {
              val int = char.toInt
              
              if (int == 9) // '\t'
                s1.some
              else if (int == 32) // ' '
                s1.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s2 =
          Lexer.State[Tok](
            2,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.findRawTerminal,
                ),
              ),
              Lexer.Yields.ToMode.Push[Tok](Lazy(s14)),
            ).some,
          )
        
        s3 =
          Lexer.State[Tok](
            3,
            char => {
              val int = char.toInt
              
              if (int == 42) // '*'
                s27.some
              else
                s3.some
            },
            None,
          )
        
        s4 =
          Lexer.State[Tok](
            4,
            _ => None,
            Lexer.Yields[Tok](
              List(
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s5 =
          Lexer.State[Tok](
            5,
            char => {
              val int = char.toInt
              
              if (int == 10) // '\n'
                s18.some
              else
                s5.some
            },
            None,
          )
        
        s6 =
          Lexer.State[Tok](
            6,
            char => {
              val int = char.toInt
              
              if (int >= 9 && int <= 10) // '\t'-'\n'
                s6.some
              else if (int == 32) // ' '
                s6.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s7 =
          Lexer.State[Tok](
            7,
            char => {
              val int = char.toInt
              
              if (int == 114) // 'r'
                s26.some
              else
                None
            },
            None,
          )
        
        s8 =
          Lexer.State[Tok](
            8,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.assocType(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s9 =
          Lexer.State[Tok](
            9,
            char => {
              val int = char.toInt
              
              if (int == 115) // 's'
                s22.some
              else
                None
            },
            None,
          )
        
        s10 =
          Lexer.State[Tok](
            10,
            char => {
              val int = char.toInt
              
              if (int >= 48 && int <= 57) // '0'-'9'
                s10.some
              else if (int >= 65 && int <= 90) // 'A'-'Z'
                s10.some
              else if (int == 95) // '_'
                s10.some
              else if (int >= 97 && int <= 122) // 'a'-'z'
                s10.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.nonTerminal(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s11 =
          Lexer.State[Tok](
            11,
            char => {
              val int = char.toInt
              
              if (int == 9) // '\t'
                s1.some
              else if (int == 32) // ' '
                s1.some
              else if (int == 10) // '\n'
                s13.some
              else if (int >= 65 && int <= 90) // 'A'-'Z'
                s0.some
              else
                None
            },
            None,
          )
        
        s12 =
          Lexer.State[Tok](
            12,
            char => {
              val int = char.toInt
              
              if (int == 97) // 'a'
                s7.some
              else
                None
            },
            None,
          )
        
        s13 =
          Lexer.State[Tok](
            13,
            _ => None,
            Lexer.Yields[Tok](
              List(
              ),
              Lexer.Yields.ToMode.Pop,
            ).some,
          )
        
        s14 =
          Lexer.State[Tok](
            14,
            char => {
              val int = char.toInt
              
              if (int == 34) // '\"'
                s24.some
              else if (int == 92) // '\\'
                s23.some
              else
                s30.some
            },
            None,
          )
        
        s15 =
          Lexer.State[Tok](
            15,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (Some(1),Some(1)),
                  Tok.escChar(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s16 =
          Lexer.State[Tok](
            16,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.findRawTerminal,
                ),
              ),
              Lexer.Yields.ToMode.Push[Tok](Lazy(s11)),
            ).some,
          )
        
        s17 =
          Lexer.State[Tok](
            17,
            char => {
              val int = char.toInt
              
              if (int >= 48 && int <= 57) // '0'-'9'
                s17.some
              else if (int >= 65 && int <= 90) // 'A'-'Z'
                s17.some
              else if (int == 95) // '_'
                s17.some
              else if (int >= 97 && int <= 122) // 'a'-'z'
                s17.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.terminal(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s18 =
          Lexer.State[Tok](
            18,
            _ => None,
            Lexer.Yields[Tok](
              List(
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s19 =
          Lexer.State[Tok](
            19,
            char => {
              val int = char.toInt
              
              if (int == 58) // ':'
                s16.some
              else
                None
            },
            None,
          )
        
        s20 =
          Lexer.State[Tok](
            20,
            char => {
              val int = char.toInt
              
              if (int == 47) // '/'
                s5.some
              else if (int == 42) // '*'
                s3.some
              else
                None
            },
            None,
          )
        
        s22 =
          Lexer.State[Tok](
            22,
            char => {
              val int = char.toInt
              
              if (int == 116) // 't'
                s12.some
              else
                None
            },
            None,
          )
        
        s23 =
          Lexer.State[Tok](
            23,
            char => {
              val int = char.toInt
              
              if (int == 34) // '\"'
                s15.some
              else if (int == 92) // '\\'
                s15.some
              else if (int == 110) // 'n'
                s15.some
              else if (int == 116) // 't'
                s15.some
              else
                None
            },
            None,
          )
        
        s24 =
          Lexer.State[Tok](
            24,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.findRawTerminal,
                ),
              ),
              Lexer.Yields.ToMode.Pop,
            ).some,
          )
        
        s25 =
          Lexer.State[Tok](
            25,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.findRawTerminal,
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s26 =
          Lexer.State[Tok](
            26,
            char => {
              val int = char.toInt
              
              if (int == 116) // 't'
                s19.some
              else
                None
            },
            None,
          )
        
        s27 =
          Lexer.State[Tok](
            27,
            char => {
              val int = char.toInt
              
              if (int == 47) // '/'
                s4.some
              else
                s3.some
            },
            None,
          )
        
        s28 =
          Lexer.State[Tok](
            28,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.listType(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s29 =
          Lexer.State[Tok](
            29,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.tilde(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s30 =
          Lexer.State[Tok](
            30,
            char => {
              val int = char.toInt
              
              if (int == 34) // '\"'
                None
              else if (int == 92) // '\\'
                None
              else
                s30.some
            },
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.chars(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        
        s21
      },
      Grammar[Tok, NonTerminal, NtRoot] {
        var s0: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s1: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s2: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s3: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s4: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s5: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s6: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s7: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s8: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s9: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s10: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s11: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s12: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s13: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s14: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s15: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s16: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s17: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s18: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s19: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s20: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s21: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s22: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s23: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s24: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s25: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s26: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s27: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s28: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s29: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s30: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s31: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s32: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s33: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s34: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s35: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s36: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s37: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s38: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s39: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s40: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s41: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s42: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s43: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s44: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s45: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s46: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s47: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s48: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s49: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s50: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s51: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s52: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s53: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s54: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s55: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s56: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s57: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s58: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s59: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s60: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s61: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s62: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s63: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s64: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s65: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s66: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s67: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s68: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s69: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s70: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s71: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s72: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s73: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s74: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s75: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s76: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s77: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s78: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s79: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s80: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s81: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s82: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s83: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s84: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s85: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s86: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s87: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s88: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s89: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s90: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s91: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s92: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s93: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s94: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s95: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s96: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s97: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s98: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s99: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s100: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s101: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s102: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s103: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s104: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s105: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s106: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s107: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s108: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s109: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s110: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s111: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s112: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s113: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s114: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s115: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s116: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s117: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s118: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s119: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s120: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s121: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s122: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s123: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s124: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s125: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s126: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s127: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s128: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s129: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s130: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s131: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s132: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s133: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s134: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s135: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s136: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s137: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s138: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s139: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s140: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s141: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s142: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s143: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s144: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s145: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s146: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s147: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s148: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s149: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s150: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s151: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s152: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s153: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s154: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s155: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s156: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s157: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s158: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s159: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s160: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s161: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s162: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s163: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s164: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s165: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s166: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s167: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s168: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s169: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s170: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s171: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s172: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s173: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s174: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s175: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s176: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s177: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s178: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s179: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s180: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s181: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s182: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s183: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s184: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s185: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s186: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s187: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s188: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s189: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s190: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s191: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s192: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s193: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s194: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s195: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s196: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s197: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s198: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s199: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s200: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s201: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s202: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s203: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s204: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s205: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s206: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s207: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s208: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s209: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s210: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s211: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s212: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s213: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s214: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s215: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s216: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s217: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s218: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s219: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s220: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s221: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s222: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s223: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s224: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s225: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s226: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s227: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s228: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s229: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s230: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s231: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s232: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s233: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s234: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s235: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s236: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s237: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s238: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s239: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s240: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s241: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s242: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s243: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s244: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s245: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s246: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s247: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s248: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s249: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s250: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s251: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s252: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s253: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s254: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s255: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s256: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s257: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s258: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s259: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s260: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s261: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s262: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s263: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s264: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s265: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s266: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s267: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s268: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s269: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s270: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s271: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s272: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s273: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s274: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s275: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s276: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s277: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s278: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s279: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s280: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s281: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s282: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s283: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s284: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s285: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s286: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s287: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s288: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s289: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s290: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s291: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s292: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s293: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s294: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s295: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s296: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s297: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s298: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s299: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s300: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s301: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s302: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s303: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s304: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s305: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s306: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s307: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s308: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s309: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s310: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s311: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s312: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s313: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s314: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s315: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s316: Grammar.State[Tok, NonTerminal, NtRoot] = null
        
        s0 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            0,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s1 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            1,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.NTBody), _) :: (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NT(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s2 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            2,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s233,
                        (tok.left, s2) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`)` =>
                      (
                        s27,
                        (tok.left, s2) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s3 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            3,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s93,
                        (tok.left, s3) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s83,
                        (tok.left, s3) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s302,
                        (tok.left, s3) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s299,
                        (tok.left, s3) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s3.onNt(nt) 
                      (
                        to,
                        (nt.right, s3) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s283
              case _: NonTerminal.Raw =>
                s237
              case _: NonTerminal.UnIgnoredElementList =>
                s16
              case _: NonTerminal.Element =>
                s272
              case _: NonTerminal.NonOptElement =>
                s197
              case _: NonTerminal.AnonList =>
                s245
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s4 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            4,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s5 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            5,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`:` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s6 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            6,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s7 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            7,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s40,
                        (tok.left, s7) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s118,
                        (tok.left, s7) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s294,
                        (tok.left, s7) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s292,
                        (tok.left, s7) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s7.onNt(nt) 
                      (
                        to,
                        (nt.right, s7) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s236
              case _: NonTerminal.Raw =>
                s273
              case _: NonTerminal.UnIgnoredElementList =>
                s26
              case _: NonTerminal.Element =>
                s107
              case _: NonTerminal.NonOptElement =>
                s217
              case _: NonTerminal.AnonList =>
                s213
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s8 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            8,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s65,
                        (tok.left, s8) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s251,
                        (tok.left, s8) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s215,
                        (tok.left, s8) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s63,
                        (tok.left, s8) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.NonOptElement =>
                s301
              case _: NonTerminal.AnonList =>
                s19
              case _: NonTerminal.Raw =>
                s253
              case _: NonTerminal.Element =>
                s311
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s9 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            9,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      (
                        s46,
                        (tok.left, s9) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s9.onNt(nt) 
                      (
                        to,
                        (nt.right, s9) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s9.onNt(nt) 
                      (
                        to,
                        (nt.right, s9) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.listType =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s9.onNt(nt) 
                      (
                        to,
                        (nt.right, s9) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s9.onNt(nt) 
                      (
                        to,
                        (nt.right, s9) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.terminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s9.onNt(nt) 
                      (
                        to,
                        (nt.right, s9) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s9.onNt(nt) 
                      (
                        to,
                        (nt.right, s9) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s9.onNt(nt) 
                      (
                        to,
                        (nt.right, s9) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s9.onNt(nt) 
                      (
                        to,
                        (nt.right, s9) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.`Opt_?` =>
                s87
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s10 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            10,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s187,
                        (tok.left, s10) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s11 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            11,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s12 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            12,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList5Head), _) :: (Left(_1: Tok.`^`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.LiftNT(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s13 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            13,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s14 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            14,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s40,
                        (tok.left, s14) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s118,
                        (tok.left, s14) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s294,
                        (tok.left, s14) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s292,
                        (tok.left, s14) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s14.onNt(nt) 
                      (
                        to,
                        (nt.right, s14) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s236
              case _: NonTerminal.Raw =>
                s273
              case _: NonTerminal.UnIgnoredElementList =>
                s229
              case _: NonTerminal.Element =>
                s107
              case _: NonTerminal.NonOptElement =>
                s217
              case _: NonTerminal.AnonList =>
                s213
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s15 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            15,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList3Head), _) :: (Left(_1: Tok.`:`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.BasicNT(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s16 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            16,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s75,
                        (tok.left, s16) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s17 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            17,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s18 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            18,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ElementListSimple._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ElementListSimple._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s19 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            19,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s20 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            20,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok =>
                      None
                  }
                case None =>
                  stack match {
                    case (Right(_3: NonTerminal.AnonList2Tail), _) :: (Left(_2: Tok.`;`), _) :: (Right(_1: NonTerminal.NT), poppedState) :: stack =>
                      val nt: NonTerminal = NonTerminal.AnonList1Head(_1, _2, _3)
                      val to = poppedState.onNt(nt)
                      (
                        to,
                        (nt.right, poppedState) :: stack,
                        None,
                      ).left.some
                    case _ =>
                      None
                  }
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s21 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            21,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s93,
                        (tok.left, s21) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s83,
                        (tok.left, s21) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s302,
                        (tok.left, s21) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s299,
                        (tok.left, s21) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s21.onNt(nt) 
                      (
                        to,
                        (nt.right, s21) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s283
              case _: NonTerminal.Raw =>
                s237
              case _: NonTerminal.UnIgnoredElementList =>
                s128
              case _: NonTerminal.Element =>
                s272
              case _: NonTerminal.NonOptElement =>
                s197
              case _: NonTerminal.AnonList =>
                s245
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s22 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            22,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s98,
                        (tok.left, s22) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s23 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            23,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      (
                        s277,
                        (tok.left, s23) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s24 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            24,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s24.onNt(nt) 
                      (
                        to,
                        (nt.right, s24) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`?` =>
                      (
                        s35,
                        (tok.left, s24) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s24.onNt(nt) 
                      (
                        to,
                        (nt.right, s24) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s24.onNt(nt) 
                      (
                        to,
                        (nt.right, s24) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.terminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s24.onNt(nt) 
                      (
                        to,
                        (nt.right, s24) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s24.onNt(nt) 
                      (
                        to,
                        (nt.right, s24) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.listType =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s24.onNt(nt) 
                      (
                        to,
                        (nt.right, s24) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s24.onNt(nt) 
                      (
                        to,
                        (nt.right, s24) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.`Opt_?` =>
                s192
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s25 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            25,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.AnonList8Tail._2
                      val to = s25.onNt(nt) 
                      (
                        to,
                        (nt.right, s25) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`|` =>
                      (
                        s102,
                        (tok.left, s25) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`:` =>
                      val nt: NonTerminal = NonTerminal.AnonList8Tail._2
                      val to = s25.onNt(nt) 
                      (
                        to,
                        (nt.right, s25) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.AnonList8Tail =>
                s214
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s26 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            26,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s120,
                        (tok.left, s26) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`)` =>
                      (
                        s180,
                        (tok.left, s26) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s27 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            27,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s226,
                        (tok.left, s27) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s28 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            28,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`:` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s29 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            29,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s312,
                        (tok.left, s29) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s100,
                        (tok.left, s29) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s142,
                        (tok.left, s29) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s95,
                        (tok.left, s29) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s29.onNt(nt) 
                      (
                        to,
                        (nt.right, s29) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s29.onNt(nt) 
                      (
                        to,
                        (nt.right, s29) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s85
              case _: NonTerminal.Raw =>
                s189
              case _: NonTerminal.AnonList3Head =>
                s15
              case _: NonTerminal.Element =>
                s151
              case _: NonTerminal.NonOptElement =>
                s82
              case _: NonTerminal.AnonList =>
                s202
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s30 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            30,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s40,
                        (tok.left, s30) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s118,
                        (tok.left, s30) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s294,
                        (tok.left, s30) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s292,
                        (tok.left, s30) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s30.onNt(nt) 
                      (
                        to,
                        (nt.right, s30) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s236
              case _: NonTerminal.Raw =>
                s273
              case _: NonTerminal.UnIgnoredElementList =>
                s203
              case _: NonTerminal.Element =>
                s107
              case _: NonTerminal.NonOptElement =>
                s217
              case _: NonTerminal.AnonList =>
                s213
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s31 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            31,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_3: NonTerminal.AnonList8Tail), _) :: (Right(_2: NonTerminal.AssocPair), _) :: (Left(_1: Tok.`|`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList8Tail._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`:` =>
                      stack match {
                        case (Right(_3: NonTerminal.AnonList8Tail), _) :: (Right(_2: NonTerminal.AssocPair), _) :: (Left(_1: Tok.`|`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList8Tail._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s32 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            32,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_3: NonTerminal.AnonList6Tail), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`|`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList6Tail._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s33 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            33,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      (
                        s39,
                        (tok.left, s33) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s34 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            34,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s43,
                        (tok.left, s34) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s41,
                        (tok.left, s34) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s141,
                        (tok.left, s34) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s81,
                        (tok.left, s34) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s34.onNt(nt) 
                      (
                        to,
                        (nt.right, s34) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s89
              case _: NonTerminal.Raw =>
                s234
              case _: NonTerminal.UnIgnoredElementList =>
                s300
              case _: NonTerminal.Element =>
                s38
              case _: NonTerminal.NonOptElement =>
                s103
              case _: NonTerminal.AnonList =>
                s170
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s35 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            35,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s36 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            36,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s37 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            37,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s38 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            38,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      (
                        s248,
                        (tok.left, s38) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s36,
                        (tok.left, s38) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      (
                        s55,
                        (tok.left, s38) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s137,
                        (tok.left, s38) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s274,
                        (tok.left, s38) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s38.onNt(nt) 
                      (
                        to,
                        (nt.right, s38) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s165
              case _: NonTerminal.Raw =>
                s166
              case _: NonTerminal.Element =>
                s42
              case _: NonTerminal.NonOptElement =>
                s260
              case _: NonTerminal.AnonList =>
                s88
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s39 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            39,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s40 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            40,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s40,
                        (tok.left, s40) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s118,
                        (tok.left, s40) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s294,
                        (tok.left, s40) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s292,
                        (tok.left, s40) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s40.onNt(nt) 
                      (
                        to,
                        (nt.right, s40) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s236
              case _: NonTerminal.Raw =>
                s273
              case _: NonTerminal.UnIgnoredElementList =>
                s2
              case _: NonTerminal.Element =>
                s107
              case _: NonTerminal.NonOptElement =>
                s217
              case _: NonTerminal.AnonList =>
                s213
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s41 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            41,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s42 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            42,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s248,
                        (tok.left, s42) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s36,
                        (tok.left, s42) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.listType =>
                      (
                        s91,
                        (tok.left, s42) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s137,
                        (tok.left, s42) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s274,
                        (tok.left, s42) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s42.onNt(nt) 
                      (
                        to,
                        (nt.right, s42) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s165
              case _: NonTerminal.Raw =>
                s166
              case _: NonTerminal.Element =>
                s42
              case _: NonTerminal.NonOptElement =>
                s260
              case _: NonTerminal.AnonList =>
                s88
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s43 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            43,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s40,
                        (tok.left, s43) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s118,
                        (tok.left, s43) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s294,
                        (tok.left, s43) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s292,
                        (tok.left, s43) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s43.onNt(nt) 
                      (
                        to,
                        (nt.right, s43) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s236
              case _: NonTerminal.Raw =>
                s273
              case _: NonTerminal.UnIgnoredElementList =>
                s310
              case _: NonTerminal.Element =>
                s107
              case _: NonTerminal.NonOptElement =>
                s217
              case _: NonTerminal.AnonList =>
                s213
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s44 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            44,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s93,
                        (tok.left, s44) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s83,
                        (tok.left, s44) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s302,
                        (tok.left, s44) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s299,
                        (tok.left, s44) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s44.onNt(nt) 
                      (
                        to,
                        (nt.right, s44) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s283
              case _: NonTerminal.Raw =>
                s237
              case _: NonTerminal.UnIgnoredElementList =>
                s162
              case _: NonTerminal.Element =>
                s272
              case _: NonTerminal.NonOptElement =>
                s197
              case _: NonTerminal.AnonList =>
                s245
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s45 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            45,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s46 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            46,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s47 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            47,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s48 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            48,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s49 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            49,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`:` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s50 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            50,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok =>
                      None
                  }
                case None =>
                  stack match {
                    case (Right(_3: NonTerminal.AnonList2Tail), _) :: (Left(_2: Tok.`;`), _) :: (Right(_1: NonTerminal.NT), poppedState) :: stack =>
                      val nt: NonTerminal = NonTerminal.AnonList2Tail._1(_1, _2, _3)
                      val to = poppedState.onNt(nt)
                      (
                        to,
                        (nt.right, poppedState) :: stack,
                        None,
                      ).left.some
                    case _ =>
                      None
                  }
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s51 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            51,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.nonTerminal =>
                      (
                        s109,
                        (tok.left, s51) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  val nt: NonTerminal = NonTerminal.AnonList2Tail._2
                  val to = s51.onNt(nt) 
                  (
                    to,
                    (nt.right, s51) :: stack,
                    None,
                  ).left.some
              }
            },
            {
              case _: NonTerminal.AnonList2Tail =>
                s50
              case _: NonTerminal.NT =>
                s71
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s52 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            52,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s308,
                        (tok.left, s52) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s53 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            53,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s54 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            54,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_4: NonTerminal.ElementListSimple), _) :: (Right(_3: NonTerminal.Element), _) :: (Left(_2: Tok.`^`), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s55 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            55,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s56 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            56,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s48,
                        (tok.left, s56) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s57 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            57,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      (
                        s257,
                        (tok.left, s57) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s57.onNt(nt) 
                      (
                        to,
                        (nt.right, s57) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.terminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s57.onNt(nt) 
                      (
                        to,
                        (nt.right, s57) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.listType =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s57.onNt(nt) 
                      (
                        to,
                        (nt.right, s57) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s57.onNt(nt) 
                      (
                        to,
                        (nt.right, s57) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`)` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s57.onNt(nt) 
                      (
                        to,
                        (nt.right, s57) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s57.onNt(nt) 
                      (
                        to,
                        (nt.right, s57) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.`Opt_?` =>
                s11
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s58 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            58,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      (
                        s53,
                        (tok.left, s58) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s59 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            59,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s259,
                        (tok.left, s59) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s250,
                        (tok.left, s59) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s124,
                        (tok.left, s59) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s116,
                        (tok.left, s59) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.NonOptElement =>
                s24
              case _: NonTerminal.AnonList =>
                s172
              case _: NonTerminal.Raw =>
                s119
              case _: NonTerminal.Element =>
                s243
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s60 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            60,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      (
                        s282,
                        (tok.left, s60) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s61 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            61,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s62 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            62,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s93,
                        (tok.left, s62) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s83,
                        (tok.left, s62) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s302,
                        (tok.left, s62) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s299,
                        (tok.left, s62) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s62.onNt(nt) 
                      (
                        to,
                        (nt.right, s62) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s283
              case _: NonTerminal.Raw =>
                s237
              case _: NonTerminal.UnIgnoredElementList =>
                s244
              case _: NonTerminal.Element =>
                s272
              case _: NonTerminal.NonOptElement =>
                s197
              case _: NonTerminal.AnonList =>
                s245
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s63 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            63,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s64 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            64,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.AnonList8Tail._2
                      val to = s64.onNt(nt) 
                      (
                        to,
                        (nt.right, s64) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`|` =>
                      (
                        s102,
                        (tok.left, s64) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`:` =>
                      val nt: NonTerminal = NonTerminal.AnonList8Tail._2
                      val to = s64.onNt(nt) 
                      (
                        to,
                        (nt.right, s64) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.AnonList8Tail =>
                s31
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s65 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            65,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s40,
                        (tok.left, s65) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s118,
                        (tok.left, s65) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s294,
                        (tok.left, s65) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s292,
                        (tok.left, s65) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s65.onNt(nt) 
                      (
                        to,
                        (nt.right, s65) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s236
              case _: NonTerminal.Raw =>
                s273
              case _: NonTerminal.UnIgnoredElementList =>
                s144
              case _: NonTerminal.Element =>
                s107
              case _: NonTerminal.NonOptElement =>
                s217
              case _: NonTerminal.AnonList =>
                s213
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s66 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            66,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s37,
                        (tok.left, s66) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s67 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            67,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s68 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            68,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s69 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            69,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s70 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            70,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`:` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s71 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            71,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      (
                        s51,
                        (tok.left, s71) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s72 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            72,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s96,
                        (tok.left, s72) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s73 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            73,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s74 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            74,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s93,
                        (tok.left, s74) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s83,
                        (tok.left, s74) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s302,
                        (tok.left, s74) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s299,
                        (tok.left, s74) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s74.onNt(nt) 
                      (
                        to,
                        (nt.right, s74) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s283
              case _: NonTerminal.Raw =>
                s237
              case _: NonTerminal.UnIgnoredElementList =>
                s164
              case _: NonTerminal.Element =>
                s272
              case _: NonTerminal.NonOptElement =>
                s197
              case _: NonTerminal.AnonList =>
                s245
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s75 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            75,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s252,
                        (tok.left, s75) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s76 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            76,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s77 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            77,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s93,
                        (tok.left, s77) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s83,
                        (tok.left, s77) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s302,
                        (tok.left, s77) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s299,
                        (tok.left, s77) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s77.onNt(nt) 
                      (
                        to,
                        (nt.right, s77) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s283
              case _: NonTerminal.Raw =>
                s237
              case _: NonTerminal.UnIgnoredElementList =>
                s125
              case _: NonTerminal.Element =>
                s272
              case _: NonTerminal.NonOptElement =>
                s197
              case _: NonTerminal.AnonList =>
                s245
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s78 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            78,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s79 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            79,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s80 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            80,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.BasicNT), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.StandardNT._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s81 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            81,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s82 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            82,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      (
                        s86,
                        (tok.left, s82) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s82.onNt(nt) 
                      (
                        to,
                        (nt.right, s82) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s82.onNt(nt) 
                      (
                        to,
                        (nt.right, s82) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.terminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s82.onNt(nt) 
                      (
                        to,
                        (nt.right, s82) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.listType =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s82.onNt(nt) 
                      (
                        to,
                        (nt.right, s82) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s82.onNt(nt) 
                      (
                        to,
                        (nt.right, s82) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s82.onNt(nt) 
                      (
                        to,
                        (nt.right, s82) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s82.onNt(nt) 
                      (
                        to,
                        (nt.right, s82) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.`Opt_?` =>
                s121
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s83 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            83,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s84 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            84,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s84.onNt(nt) 
                      (
                        to,
                        (nt.right, s84) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s259,
                        (tok.left, s84) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s250,
                        (tok.left, s84) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s116,
                        (tok.left, s84) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s84.onNt(nt) 
                      (
                        to,
                        (nt.right, s84) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.listType =>
                      (
                        s212,
                        (tok.left, s84) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s124,
                        (tok.left, s84) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s156
              case _: NonTerminal.Raw =>
                s119
              case _: NonTerminal.Element =>
                s84
              case _: NonTerminal.NonOptElement =>
                s24
              case _: NonTerminal.AnonList =>
                s172
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s85 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            85,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.AnonList4Tail._2
                      val to = s85.onNt(nt) 
                      (
                        to,
                        (nt.right, s85) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`|` =>
                      (
                        s185,
                        (tok.left, s85) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.AnonList4Tail =>
                s145
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s86 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            86,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s87 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            87,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s88 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            88,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s89 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            89,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`^` =>
                      (
                        s59,
                        (tok.left, s89) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s90 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            90,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s194,
                        (tok.left, s90) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s91 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            91,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s92 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            92,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s221,
                        (tok.left, s92) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s93 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            93,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s40,
                        (tok.left, s93) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s118,
                        (tok.left, s93) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s294,
                        (tok.left, s93) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s292,
                        (tok.left, s93) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s93.onNt(nt) 
                      (
                        to,
                        (nt.right, s93) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s236
              case _: NonTerminal.Raw =>
                s273
              case _: NonTerminal.UnIgnoredElementList =>
                s297
              case _: NonTerminal.Element =>
                s107
              case _: NonTerminal.NonOptElement =>
                s217
              case _: NonTerminal.AnonList =>
                s213
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s94 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            94,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_3: NonTerminal.AnonList4Tail), _) :: (Right(_2: NonTerminal.ElementListSimple), _) :: (Left(_1: Tok.`|`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList4Tail._1(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s95 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            95,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s208,
                        (tok.left, s95) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.chars =>
                      (
                        s150,
                        (tok.left, s95) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Char =>
                s131
              case _: NonTerminal.AnonList9Head =>
                s267
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s96 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            96,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s97 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            97,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s98 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            98,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s99 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            99,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ElementListSimple._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s100 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            100,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s101 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            101,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s101.onNt(nt) 
                      (
                        to,
                        (nt.right, s101) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s210,
                        (tok.left, s101) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s152,
                        (tok.left, s101) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.listType =>
                      (
                        s113,
                        (tok.left, s101) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s139,
                        (tok.left, s101) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`)` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s101.onNt(nt) 
                      (
                        to,
                        (nt.right, s101) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s235,
                        (tok.left, s101) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s220
              case _: NonTerminal.Raw =>
                s256
              case _: NonTerminal.Element =>
                s101
              case _: NonTerminal.NonOptElement =>
                s207
              case _: NonTerminal.AnonList =>
                s138
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s102 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            102,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.assocType =>
                      (
                        s155,
                        (tok.left, s102) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.AssocPair =>
                s64
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s103 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            103,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s103.onNt(nt) 
                      (
                        to,
                        (nt.right, s103) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`?` =>
                      (
                        s206,
                        (tok.left, s103) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s103.onNt(nt) 
                      (
                        to,
                        (nt.right, s103) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s103.onNt(nt) 
                      (
                        to,
                        (nt.right, s103) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s103.onNt(nt) 
                      (
                        to,
                        (nt.right, s103) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.listType =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s103.onNt(nt) 
                      (
                        to,
                        (nt.right, s103) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s103.onNt(nt) 
                      (
                        to,
                        (nt.right, s103) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.terminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s103.onNt(nt) 
                      (
                        to,
                        (nt.right, s103) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s103.onNt(nt) 
                      (
                        to,
                        (nt.right, s103) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.`Opt_?` =>
                s278
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s104 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            104,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s14,
                        (tok.left, s104) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s97,
                        (tok.left, s104) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s291,
                        (tok.left, s104) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s225,
                        (tok.left, s104) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.NonOptElement =>
                s57
              case _: NonTerminal.AnonList =>
                s61
              case _: NonTerminal.Raw =>
                s76
              case _: NonTerminal.Element =>
                s178
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s105 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            105,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_2: NonTerminal.Element), _) :: (Left(_1: Tok.assocType), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AssocPair(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_2: NonTerminal.Element), _) :: (Left(_1: Tok.assocType), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AssocPair(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`:` =>
                      stack match {
                        case (Right(_2: NonTerminal.Element), _) :: (Left(_1: Tok.assocType), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AssocPair(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      (
                        s28,
                        (tok.left, s105) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s106 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            106,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_4: NonTerminal.ElementListSimple), _) :: (Right(_3: NonTerminal.Element), _) :: (Left(_2: Tok.`^`), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_4: NonTerminal.ElementListSimple), _) :: (Right(_3: NonTerminal.Element), _) :: (Left(_2: Tok.`^`), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s107 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            107,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      (
                        s36,
                        (tok.left, s107) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.listType =>
                      (
                        s6,
                        (tok.left, s107) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s137,
                        (tok.left, s107) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      (
                        s248,
                        (tok.left, s107) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s274,
                        (tok.left, s107) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s107.onNt(nt) 
                      (
                        to,
                        (nt.right, s107) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s165
              case _: NonTerminal.Raw =>
                s166
              case _: NonTerminal.Element =>
                s42
              case _: NonTerminal.NonOptElement =>
                s260
              case _: NonTerminal.AnonList =>
                s88
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s108 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            108,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.listType), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ListNT._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s109 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            109,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`^` =>
                      (
                        s286,
                        (tok.left, s109) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.tilde =>
                      (
                        s147,
                        (tok.left, s109) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`:` =>
                      (
                        s29,
                        (tok.left, s109) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.listType =>
                      (
                        s34,
                        (tok.left, s109) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.BasicNT =>
                s80
              case _: NonTerminal.AssocNT =>
                s285
              case _: NonTerminal.StandardNT =>
                s146
              case _: NonTerminal.ListNT =>
                s240
              case _: NonTerminal.LiftNT =>
                s127
              case _: NonTerminal.NTBody =>
                s1
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s110 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            110,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s111 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            111,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s289,
                        (tok.left, s111) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s112 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            112,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s113 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            113,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s114 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            114,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s314,
                        (tok.left, s114) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`)` =>
                      (
                        s219,
                        (tok.left, s114) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s115 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            115,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      (
                        s153,
                        (tok.left, s115) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s116 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            116,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s117 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            117,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok =>
                      None
                  }
                case None =>
                  stack match {
                    case (Right(ntRoot: NtRoot), _) :: Nil =>
                      ntRoot.right.some
                    case _ =>
                      None
                  }
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s118 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            118,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s119 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            119,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s120 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            120,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s93,
                        (tok.left, s120) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s83,
                        (tok.left, s120) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s302,
                        (tok.left, s120) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s299,
                        (tok.left, s120) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s120.onNt(nt) 
                      (
                        to,
                        (nt.right, s120) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s283
              case _: NonTerminal.Raw =>
                s237
              case _: NonTerminal.UnIgnoredElementList =>
                s287
              case _: NonTerminal.Element =>
                s272
              case _: NonTerminal.NonOptElement =>
                s197
              case _: NonTerminal.AnonList =>
                s245
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s121 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            121,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s122 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            122,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      val to = s122.onNt(nt) 
                      (
                        to,
                        (nt.right, s122) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`|` =>
                      (
                        s171,
                        (tok.left, s122) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.AnonList6Tail =>
                s140
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s123 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            123,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`^` =>
                      (
                        s286,
                        (tok.left, s123) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`:` =>
                      (
                        s29,
                        (tok.left, s123) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.BasicNT =>
                s80
              case _: NonTerminal.StandardNT =>
                s184
              case _: NonTerminal.LiftNT =>
                s127
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s124 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            124,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s208,
                        (tok.left, s124) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.chars =>
                      (
                        s150,
                        (tok.left, s124) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Char =>
                s131
              case _: NonTerminal.AnonList9Head =>
                s58
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s125 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            125,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s239,
                        (tok.left, s125) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s126 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            126,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s130,
                        (tok.left, s126) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s127 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            127,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.LiftNT), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.StandardNT._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s128 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            128,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s190,
                        (tok.left, s128) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s129 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            129,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_4: NonTerminal.ElementListSimple), _) :: (Right(_3: NonTerminal.Element), _) :: (Left(_2: Tok.`^`), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s130 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            130,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s255,
                        (tok.left, s130) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s131 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            131,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s208,
                        (tok.left, s131) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.chars =>
                      (
                        s150,
                        (tok.left, s131) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.AnonList10Tail._2
                      val to = s131.onNt(nt) 
                      (
                        to,
                        (nt.right, s131) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Char =>
                s284
              case _: NonTerminal.AnonList10Tail =>
                s209
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s132 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            132,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s208,
                        (tok.left, s132) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.chars =>
                      (
                        s150,
                        (tok.left, s132) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Char =>
                s131
              case _: NonTerminal.AnonList9Head =>
                s231
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s133 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            133,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s21,
                        (tok.left, s133) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`)` =>
                      (
                        s199,
                        (tok.left, s133) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s134 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            134,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s17,
                        (tok.left, s134) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s135 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            135,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s90,
                        (tok.left, s135) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s136 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            136,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s40,
                        (tok.left, s136) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s118,
                        (tok.left, s136) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s294,
                        (tok.left, s136) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s292,
                        (tok.left, s136) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s136.onNt(nt) 
                      (
                        to,
                        (nt.right, s136) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s236
              case _: NonTerminal.Raw =>
                s273
              case _: NonTerminal.UnIgnoredElementList =>
                s249
              case _: NonTerminal.Element =>
                s107
              case _: NonTerminal.NonOptElement =>
                s217
              case _: NonTerminal.AnonList =>
                s213
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s137 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            137,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s208,
                        (tok.left, s137) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.chars =>
                      (
                        s150,
                        (tok.left, s137) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Char =>
                s131
              case _: NonTerminal.AnonList9Head =>
                s159
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s138 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            138,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s139 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            139,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s208,
                        (tok.left, s139) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.chars =>
                      (
                        s150,
                        (tok.left, s139) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Char =>
                s131
              case _: NonTerminal.AnonList9Head =>
                s223
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s140 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            140,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList6Tail), _) :: (Right(_1: NonTerminal.UnIgnoredElementList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList5Head(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s141 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            141,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s208,
                        (tok.left, s141) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.chars =>
                      (
                        s150,
                        (tok.left, s141) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Char =>
                s131
              case _: NonTerminal.AnonList9Head =>
                s115
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s142 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            142,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s143 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            143,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s144 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            144,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s313,
                        (tok.left, s144) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`)` =>
                      (
                        s238,
                        (tok.left, s144) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s145 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            145,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList4Tail), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList3Head(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s146 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            146,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.StandardNT), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NTBody._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s147 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            147,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.assocType =>
                      (
                        s155,
                        (tok.left, s147) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.AssocPair =>
                s25
              case _: NonTerminal.AnonList7Head =>
                s123
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s148 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            148,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.nonTerminal =>
                      (
                        s109,
                        (tok.left, s148) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.AnonList1Head =>
                s205
              case _: NonTerminal.NT =>
                s241
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s149 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            149,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s150 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            150,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_1: Tok.chars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Char._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.chars =>
                      stack match {
                        case (Left(_1: Tok.chars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Char._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.chars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Char._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s151 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            151,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s312,
                        (tok.left, s151) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s100,
                        (tok.left, s151) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s142,
                        (tok.left, s151) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.listType =>
                      (
                        s160,
                        (tok.left, s151) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s95,
                        (tok.left, s151) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s151.onNt(nt) 
                      (
                        to,
                        (nt.right, s151) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s151.onNt(nt) 
                      (
                        to,
                        (nt.right, s151) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s18
              case _: NonTerminal.Raw =>
                s189
              case _: NonTerminal.Element =>
                s151
              case _: NonTerminal.NonOptElement =>
                s82
              case _: NonTerminal.AnonList =>
                s202
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s152 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            152,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s153 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            153,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s154 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            154,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      val to = s154.onNt(nt) 
                      (
                        to,
                        (nt.right, s154) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`|` =>
                      (
                        s171,
                        (tok.left, s154) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.AnonList6Tail =>
                s32
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s155 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            155,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s136,
                        (tok.left, s155) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s70,
                        (tok.left, s155) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s242,
                        (tok.left, s155) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s264,
                        (tok.left, s155) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.NonOptElement =>
                s201
              case _: NonTerminal.AnonList =>
                s303
              case _: NonTerminal.Raw =>
                s276
              case _: NonTerminal.Element =>
                s105
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s156 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            156,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ElementListSimple._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ElementListSimple._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s157 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            157,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s158 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            158,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s159 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            159,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      (
                        s47,
                        (tok.left, s159) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s160 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            160,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s161 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            161,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s162 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            162,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s216,
                        (tok.left, s162) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s163 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            163,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_4: NonTerminal.ElementListSimple), _) :: (Right(_3: NonTerminal.Element), _) :: (Left(_2: Tok.`^`), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_4: NonTerminal.ElementListSimple), _) :: (Right(_3: NonTerminal.Element), _) :: (Left(_2: Tok.`^`), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s164 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            164,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s211,
                        (tok.left, s164) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s165 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            165,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ElementListSimple._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s166 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            166,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s167 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            167,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.AnonList4Tail._2
                      val to = s167.onNt(nt) 
                      (
                        to,
                        (nt.right, s167) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`|` =>
                      (
                        s185,
                        (tok.left, s167) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.AnonList4Tail =>
                s94
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s168 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            168,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s72,
                        (tok.left, s168) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s169 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            169,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s170 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            170,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s171 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            171,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s30,
                        (tok.left, s171) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s13,
                        (tok.left, s171) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s258,
                        (tok.left, s171) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s288,
                        (tok.left, s171) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s171.onNt(nt) 
                      (
                        to,
                        (nt.right, s171) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s295
              case _: NonTerminal.Raw =>
                s112
              case _: NonTerminal.UnIgnoredElementList =>
                s154
              case _: NonTerminal.Element =>
                s309
              case _: NonTerminal.NonOptElement =>
                s9
              case _: NonTerminal.AnonList =>
                s188
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s172 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            172,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s173 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            173,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s235,
                        (tok.left, s173) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s210,
                        (tok.left, s173) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s139,
                        (tok.left, s173) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s152,
                        (tok.left, s173) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.NonOptElement =>
                s207
              case _: NonTerminal.AnonList =>
                s138
              case _: NonTerminal.Raw =>
                s256
              case _: NonTerminal.Element =>
                s262
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s174 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            174,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s175 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            175,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      (
                        s224,
                        (tok.left, s175) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s176 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            176,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s177 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            177,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s178 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            178,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.nonTerminal =>
                      (
                        s97,
                        (tok.left, s178) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s225,
                        (tok.left, s178) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.listType =>
                      (
                        s183,
                        (tok.left, s178) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s291,
                        (tok.left, s178) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`)` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s178.onNt(nt) 
                      (
                        to,
                        (nt.right, s178) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s14,
                        (tok.left, s178) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s129
              case _: NonTerminal.Raw =>
                s76
              case _: NonTerminal.Element =>
                s198
              case _: NonTerminal.NonOptElement =>
                s57
              case _: NonTerminal.AnonList =>
                s61
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s179 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            179,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      (
                        s45,
                        (tok.left, s179) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s179.onNt(nt) 
                      (
                        to,
                        (nt.right, s179) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s179.onNt(nt) 
                      (
                        to,
                        (nt.right, s179) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s179.onNt(nt) 
                      (
                        to,
                        (nt.right, s179) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.listType =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s179.onNt(nt) 
                      (
                        to,
                        (nt.right, s179) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s179.onNt(nt) 
                      (
                        to,
                        (nt.right, s179) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.terminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s179.onNt(nt) 
                      (
                        to,
                        (nt.right, s179) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s179.onNt(nt) 
                      (
                        to,
                        (nt.right, s179) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.`Opt_?` =>
                s304
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s180 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            180,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s149,
                        (tok.left, s180) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s181 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            181,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s312,
                        (tok.left, s181) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s100,
                        (tok.left, s181) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s142,
                        (tok.left, s181) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.listType =>
                      (
                        s160,
                        (tok.left, s181) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s95,
                        (tok.left, s181) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s181.onNt(nt) 
                      (
                        to,
                        (nt.right, s181) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s181.onNt(nt) 
                      (
                        to,
                        (nt.right, s181) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s106
              case _: NonTerminal.Raw =>
                s189
              case _: NonTerminal.Element =>
                s151
              case _: NonTerminal.NonOptElement =>
                s82
              case _: NonTerminal.AnonList =>
                s202
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s182 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            182,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s93,
                        (tok.left, s182) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s83,
                        (tok.left, s182) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s302,
                        (tok.left, s182) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s299,
                        (tok.left, s182) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s182.onNt(nt) 
                      (
                        to,
                        (nt.right, s182) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s283
              case _: NonTerminal.Raw =>
                s237
              case _: NonTerminal.UnIgnoredElementList =>
                s126
              case _: NonTerminal.Element =>
                s272
              case _: NonTerminal.NonOptElement =>
                s197
              case _: NonTerminal.AnonList =>
                s245
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s183 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            183,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s184 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            184,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_3: NonTerminal.StandardNT), _) :: (Right(_2: NonTerminal.AnonList7Head), _) :: (Left(_1: Tok.tilde), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AssocNT(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s185 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            185,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s312,
                        (tok.left, s185) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s100,
                        (tok.left, s185) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s142,
                        (tok.left, s185) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s95,
                        (tok.left, s185) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s185.onNt(nt) 
                      (
                        to,
                        (nt.right, s185) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s185.onNt(nt) 
                      (
                        to,
                        (nt.right, s185) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s167
              case _: NonTerminal.Raw =>
                s189
              case _: NonTerminal.Element =>
                s151
              case _: NonTerminal.NonOptElement =>
                s82
              case _: NonTerminal.AnonList =>
                s202
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s186 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            186,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s316,
                        (tok.left, s186) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s187 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            187,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`:` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s188 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            188,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s189 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            189,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s190 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            190,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s196,
                        (tok.left, s190) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s191 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            191,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList10Tail), _) :: (Right(_1: NonTerminal.Char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList10Tail._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s192 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            192,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s193 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            193,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.nonTerminal =>
                      (
                        s109,
                        (tok.left, s193) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  val nt: NonTerminal = NonTerminal.AnonList2Tail._2
                  val to = s193.onNt(nt) 
                  (
                    to,
                    (nt.right, s193) :: stack,
                    None,
                  ).left.some
              }
            },
            {
              case _: NonTerminal.AnonList2Tail =>
                s20
              case _: NonTerminal.NT =>
                s71
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s194 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            194,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s195 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            195,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s62,
                        (tok.left, s195) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`)` =>
                      (
                        s22,
                        (tok.left, s195) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s196 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            196,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s197 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            197,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      (
                        s315,
                        (tok.left, s197) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s197.onNt(nt) 
                      (
                        to,
                        (nt.right, s197) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.listType =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s197.onNt(nt) 
                      (
                        to,
                        (nt.right, s197) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s197.onNt(nt) 
                      (
                        to,
                        (nt.right, s197) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`)` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s197.onNt(nt) 
                      (
                        to,
                        (nt.right, s197) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s197.onNt(nt) 
                      (
                        to,
                        (nt.right, s197) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.terminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s197.onNt(nt) 
                      (
                        to,
                        (nt.right, s197) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s197.onNt(nt) 
                      (
                        to,
                        (nt.right, s197) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.`Opt_?` =>
                s204
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s198 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            198,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.nonTerminal =>
                      (
                        s97,
                        (tok.left, s198) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s225,
                        (tok.left, s198) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.listType =>
                      (
                        s183,
                        (tok.left, s198) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s291,
                        (tok.left, s198) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`)` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s198.onNt(nt) 
                      (
                        to,
                        (nt.right, s198) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s14,
                        (tok.left, s198) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s306
              case _: NonTerminal.Raw =>
                s76
              case _: NonTerminal.Element =>
                s198
              case _: NonTerminal.NonOptElement =>
                s57
              case _: NonTerminal.AnonList =>
                s61
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s199 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            199,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s177,
                        (tok.left, s199) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s200 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            200,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s201 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            201,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      (
                        s5,
                        (tok.left, s201) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`:` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s201.onNt(nt) 
                      (
                        to,
                        (nt.right, s201) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s201.onNt(nt) 
                      (
                        to,
                        (nt.right, s201) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s201.onNt(nt) 
                      (
                        to,
                        (nt.right, s201) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.listType =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s201.onNt(nt) 
                      (
                        to,
                        (nt.right, s201) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.`Opt_?` =>
                s49
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s202 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            202,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s203 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            203,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s77,
                        (tok.left, s203) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`)` =>
                      (
                        s56,
                        (tok.left, s203) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s204 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            204,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s205 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            205,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok =>
                      None
                  }
                case None =>
                  stack match {
                    case (Right(_3: NonTerminal.AnonList1Head), _) :: (Left(_2: Tok.mode), _) :: (Left(_1: Tok.`@start:`), poppedState) :: stack =>
                      val nt: NonTerminal = NonTerminal.Grammar(_1, _2, _3)
                      val to = poppedState.onNt(nt)
                      (
                        to,
                        (nt.right, poppedState) :: stack,
                        None,
                      ).left.some
                    case _ =>
                      None
                  }
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s206 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            206,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s207 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            207,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s207.onNt(nt) 
                      (
                        to,
                        (nt.right, s207) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`?` =>
                      (
                        s270,
                        (tok.left, s207) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s207.onNt(nt) 
                      (
                        to,
                        (nt.right, s207) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.terminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s207.onNt(nt) 
                      (
                        to,
                        (nt.right, s207) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.listType =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s207.onNt(nt) 
                      (
                        to,
                        (nt.right, s207) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s207.onNt(nt) 
                      (
                        to,
                        (nt.right, s207) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`)` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s207.onNt(nt) 
                      (
                        to,
                        (nt.right, s207) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s207.onNt(nt) 
                      (
                        to,
                        (nt.right, s207) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.`Opt_?` =>
                s266
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s208 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            208,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Char._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.chars =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Char._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Char._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s209 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            209,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList10Tail), _) :: (Right(_1: NonTerminal.Char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList9Head(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s210 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            210,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s211 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            211,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s67,
                        (tok.left, s211) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s212 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            212,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s213 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            213,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s214 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            214,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList8Tail), _) :: (Right(_1: NonTerminal.AssocPair), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList7Head(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`:` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList8Tail), _) :: (Right(_1: NonTerminal.AssocPair), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList7Head(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s215 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            215,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s208,
                        (tok.left, s215) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.chars =>
                      (
                        s150,
                        (tok.left, s215) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Char =>
                s131
              case _: NonTerminal.AnonList9Head =>
                s271
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s216 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            216,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s110,
                        (tok.left, s216) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s217 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            217,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s217.onNt(nt) 
                      (
                        to,
                        (nt.right, s217) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`?` =>
                      (
                        s79,
                        (tok.left, s217) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s217.onNt(nt) 
                      (
                        to,
                        (nt.right, s217) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.listType =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s217.onNt(nt) 
                      (
                        to,
                        (nt.right, s217) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s217.onNt(nt) 
                      (
                        to,
                        (nt.right, s217) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`)` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s217.onNt(nt) 
                      (
                        to,
                        (nt.right, s217) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s217.onNt(nt) 
                      (
                        to,
                        (nt.right, s217) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.terminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s217.onNt(nt) 
                      (
                        to,
                        (nt.right, s217) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s217.onNt(nt) 
                      (
                        to,
                        (nt.right, s217) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.`Opt_?` =>
                s143
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s218 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            218,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s219 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            219,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s157,
                        (tok.left, s219) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s220 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            220,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ElementListSimple._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ElementListSimple._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s221 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            221,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s222 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            222,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s218,
                        (tok.left, s222) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s223 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            223,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      (
                        s247,
                        (tok.left, s223) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s224 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            224,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s225 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            225,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s226 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            226,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s227 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            227,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s228 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            228,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_4: NonTerminal.ElementListSimple), _) :: (Right(_3: NonTerminal.Element), _) :: (Left(_2: Tok.`^`), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_4: NonTerminal.ElementListSimple), _) :: (Right(_3: NonTerminal.Element), _) :: (Left(_2: Tok.`^`), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s229 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            229,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s3,
                        (tok.left, s229) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`)` =>
                      (
                        s52,
                        (tok.left, s229) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s230 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            230,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`@start:` =>
                      (
                        s261,
                        (tok.left, s230) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Grammar =>
                s117
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s231 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            231,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      (
                        s68,
                        (tok.left, s231) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s232 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            232,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s233 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            233,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s93,
                        (tok.left, s233) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s83,
                        (tok.left, s233) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s302,
                        (tok.left, s233) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s299,
                        (tok.left, s233) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s233.onNt(nt) 
                      (
                        to,
                        (nt.right, s233) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s283
              case _: NonTerminal.Raw =>
                s237
              case _: NonTerminal.UnIgnoredElementList =>
                s186
              case _: NonTerminal.Element =>
                s272
              case _: NonTerminal.NonOptElement =>
                s197
              case _: NonTerminal.AnonList =>
                s245
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s234 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            234,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s235 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            235,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s40,
                        (tok.left, s235) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s118,
                        (tok.left, s235) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s294,
                        (tok.left, s235) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s292,
                        (tok.left, s235) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s235.onNt(nt) 
                      (
                        to,
                        (nt.right, s235) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s236
              case _: NonTerminal.Raw =>
                s273
              case _: NonTerminal.UnIgnoredElementList =>
                s195
              case _: NonTerminal.Element =>
                s107
              case _: NonTerminal.NonOptElement =>
                s217
              case _: NonTerminal.AnonList =>
                s213
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s236 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            236,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`^` =>
                      (
                        s173,
                        (tok.left, s236) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s237 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            237,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s238 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            238,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s263,
                        (tok.left, s238) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s239 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            239,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s293,
                        (tok.left, s239) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s240 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            240,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.ListNT), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NTBody._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s241 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            241,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      (
                        s193,
                        (tok.left, s241) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s242 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            242,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s208,
                        (tok.left, s242) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.chars =>
                      (
                        s150,
                        (tok.left, s242) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Char =>
                s131
              case _: NonTerminal.AnonList9Head =>
                s23
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s243 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            243,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s243.onNt(nt) 
                      (
                        to,
                        (nt.right, s243) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s259,
                        (tok.left, s243) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s250,
                        (tok.left, s243) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s116,
                        (tok.left, s243) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s243.onNt(nt) 
                      (
                        to,
                        (nt.right, s243) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.listType =>
                      (
                        s212,
                        (tok.left, s243) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s124,
                        (tok.left, s243) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s228
              case _: NonTerminal.Raw =>
                s119
              case _: NonTerminal.Element =>
                s84
              case _: NonTerminal.NonOptElement =>
                s24
              case _: NonTerminal.AnonList =>
                s172
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s244 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            244,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s222,
                        (tok.left, s244) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s245 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            245,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s246 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            246,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s74,
                        (tok.left, s246) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`)` =>
                      (
                        s134,
                        (tok.left, s246) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s247 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            247,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s248 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            248,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s40,
                        (tok.left, s248) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s118,
                        (tok.left, s248) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s294,
                        (tok.left, s248) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s292,
                        (tok.left, s248) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s248.onNt(nt) 
                      (
                        to,
                        (nt.right, s248) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s236
              case _: NonTerminal.Raw =>
                s273
              case _: NonTerminal.UnIgnoredElementList =>
                s133
              case _: NonTerminal.Element =>
                s107
              case _: NonTerminal.NonOptElement =>
                s217
              case _: NonTerminal.AnonList =>
                s213
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s249 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            249,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s182,
                        (tok.left, s249) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`)` =>
                      (
                        s10,
                        (tok.left, s249) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s250 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            250,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s251 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            251,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s252 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            252,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s253 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            253,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s254 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            254,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s312,
                        (tok.left, s254) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s100,
                        (tok.left, s254) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s95,
                        (tok.left, s254) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s142,
                        (tok.left, s254) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.NonOptElement =>
                s82
              case _: NonTerminal.AnonList =>
                s202
              case _: NonTerminal.Raw =>
                s189
              case _: NonTerminal.Element =>
                s181
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s255 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            255,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`:` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s256 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            256,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s257 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            257,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s258 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            258,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s208,
                        (tok.left, s258) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.chars =>
                      (
                        s150,
                        (tok.left, s258) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Char =>
                s131
              case _: NonTerminal.AnonList9Head =>
                s281
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s259 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            259,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s40,
                        (tok.left, s259) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s118,
                        (tok.left, s259) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s294,
                        (tok.left, s259) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s292,
                        (tok.left, s259) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s259.onNt(nt) 
                      (
                        to,
                        (nt.right, s259) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s236
              case _: NonTerminal.Raw =>
                s273
              case _: NonTerminal.UnIgnoredElementList =>
                s246
              case _: NonTerminal.Element =>
                s107
              case _: NonTerminal.NonOptElement =>
                s217
              case _: NonTerminal.AnonList =>
                s213
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s260 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            260,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      (
                        s232,
                        (tok.left, s260) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s260.onNt(nt) 
                      (
                        to,
                        (nt.right, s260) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s260.onNt(nt) 
                      (
                        to,
                        (nt.right, s260) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.listType =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s260.onNt(nt) 
                      (
                        to,
                        (nt.right, s260) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s260.onNt(nt) 
                      (
                        to,
                        (nt.right, s260) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.terminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s260.onNt(nt) 
                      (
                        to,
                        (nt.right, s260) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s260.onNt(nt) 
                      (
                        to,
                        (nt.right, s260) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.`Opt_?` =>
                s174
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s261 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            261,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.mode =>
                      (
                        s148,
                        (tok.left, s261) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s262 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            262,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s262.onNt(nt) 
                      (
                        to,
                        (nt.right, s262) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s210,
                        (tok.left, s262) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s152,
                        (tok.left, s262) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.listType =>
                      (
                        s113,
                        (tok.left, s262) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s139,
                        (tok.left, s262) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`)` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s262.onNt(nt) 
                      (
                        to,
                        (nt.right, s262) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`(` =>
                      (
                        s235,
                        (tok.left, s262) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s163
              case _: NonTerminal.Raw =>
                s256
              case _: NonTerminal.Element =>
                s101
              case _: NonTerminal.NonOptElement =>
                s207
              case _: NonTerminal.AnonList =>
                s138
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s263 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            263,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s264 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            264,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`:` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s265 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            265,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s266 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            266,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s267 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            267,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      (
                        s176,
                        (tok.left, s267) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s268 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            268,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s269 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            269,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s7,
                        (tok.left, s269) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s78,
                        (tok.left, s269) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s132,
                        (tok.left, s269) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s265,
                        (tok.left, s269) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s269.onNt(nt) 
                      (
                        to,
                        (nt.right, s269) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s280
              case _: NonTerminal.Raw =>
                s158
              case _: NonTerminal.UnIgnoredElementList =>
                s108
              case _: NonTerminal.Element =>
                s275
              case _: NonTerminal.NonOptElement =>
                s179
              case _: NonTerminal.AnonList =>
                s73
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s270 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            270,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s271 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            271,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      (
                        s227,
                        (tok.left, s271) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s272 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            272,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.nonTerminal =>
                      (
                        s36,
                        (tok.left, s272) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.listType =>
                      (
                        s169,
                        (tok.left, s272) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s137,
                        (tok.left, s272) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      (
                        s248,
                        (tok.left, s272) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s274,
                        (tok.left, s272) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s272.onNt(nt) 
                      (
                        to,
                        (nt.right, s272) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s165
              case _: NonTerminal.Raw =>
                s166
              case _: NonTerminal.Element =>
                s42
              case _: NonTerminal.NonOptElement =>
                s260
              case _: NonTerminal.AnonList =>
                s88
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s273 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            273,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s274 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            274,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s275 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            275,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s248,
                        (tok.left, s275) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s36,
                        (tok.left, s275) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      (
                        s290,
                        (tok.left, s275) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s137,
                        (tok.left, s275) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s274,
                        (tok.left, s275) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s275.onNt(nt) 
                      (
                        to,
                        (nt.right, s275) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s165
              case _: NonTerminal.Raw =>
                s166
              case _: NonTerminal.Element =>
                s42
              case _: NonTerminal.NonOptElement =>
                s260
              case _: NonTerminal.AnonList =>
                s88
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s276 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            276,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`:` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s277 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            277,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`:` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s278 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            278,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s279 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            279,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s161,
                        (tok.left, s279) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s280 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            280,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`^` =>
                      (
                        s8,
                        (tok.left, s280) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s281 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            281,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      (
                        s298,
                        (tok.left, s281) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s282 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            282,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s283 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            283,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`^` =>
                      (
                        s104,
                        (tok.left, s283) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s284 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            284,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s208,
                        (tok.left, s284) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.chars =>
                      (
                        s150,
                        (tok.left, s284) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.AnonList10Tail._2
                      val to = s284.onNt(nt) 
                      (
                        to,
                        (nt.right, s284) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Char =>
                s284
              case _: NonTerminal.AnonList10Tail =>
                s191
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s285 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            285,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.AssocNT), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NTBody._3(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s286 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            286,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s30,
                        (tok.left, s286) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s13,
                        (tok.left, s286) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s258,
                        (tok.left, s286) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s288,
                        (tok.left, s286) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s286.onNt(nt) 
                      (
                        to,
                        (nt.right, s286) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s295
              case _: NonTerminal.Raw =>
                s112
              case _: NonTerminal.UnIgnoredElementList =>
                s122
              case _: NonTerminal.Element =>
                s309
              case _: NonTerminal.AnonList5Head =>
                s12
              case _: NonTerminal.NonOptElement =>
                s9
              case _: NonTerminal.AnonList =>
                s188
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s287 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            287,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s92,
                        (tok.left, s287) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s288 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            288,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s289 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            289,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s69,
                        (tok.left, s289) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s290 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            290,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s291 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            291,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s208,
                        (tok.left, s291) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.chars =>
                      (
                        s150,
                        (tok.left, s291) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Char =>
                s131
              case _: NonTerminal.AnonList9Head =>
                s175
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s292 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            292,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s293 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            293,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s294 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            294,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s208,
                        (tok.left, s294) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.chars =>
                      (
                        s150,
                        (tok.left, s294) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Char =>
                s131
              case _: NonTerminal.AnonList9Head =>
                s33
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s295 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            295,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`^` =>
                      (
                        s254,
                        (tok.left, s295) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s296 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            296,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s65,
                        (tok.left, s296) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s251,
                        (tok.left, s296) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s63,
                        (tok.left, s296) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s296.onNt(nt) 
                      (
                        to,
                        (nt.right, s296) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.listType =>
                      (
                        s200,
                        (tok.left, s296) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s215,
                        (tok.left, s296) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s99
              case _: NonTerminal.Raw =>
                s253
              case _: NonTerminal.Element =>
                s296
              case _: NonTerminal.NonOptElement =>
                s301
              case _: NonTerminal.AnonList =>
                s19
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s297 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            297,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s307,
                        (tok.left, s297) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`)` =>
                      (
                        s279,
                        (tok.left, s297) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s298 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            298,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s299 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            299,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s300 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            300,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s269,
                        (tok.left, s300) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.listType), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ListNT._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s301 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            301,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      (
                        s305,
                        (tok.left, s301) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s301.onNt(nt) 
                      (
                        to,
                        (nt.right, s301) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s301.onNt(nt) 
                      (
                        to,
                        (nt.right, s301) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.terminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s301.onNt(nt) 
                      (
                        to,
                        (nt.right, s301) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s301.onNt(nt) 
                      (
                        to,
                        (nt.right, s301) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.listType =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s301.onNt(nt) 
                      (
                        to,
                        (nt.right, s301) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      val to = s301.onNt(nt) 
                      (
                        to,
                        (nt.right, s301) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.`Opt_?` =>
                s0
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s302 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            302,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s208,
                        (tok.left, s302) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.chars =>
                      (
                        s150,
                        (tok.left, s302) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.Char =>
                s131
              case _: NonTerminal.AnonList9Head =>
                s60
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s303 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            303,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`:` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s304 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            304,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s305 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            305,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s306 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            306,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ElementListSimple._1(_1, _2)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s307 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            307,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s93,
                        (tok.left, s307) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s83,
                        (tok.left, s307) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s302,
                        (tok.left, s307) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s299,
                        (tok.left, s307) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s307.onNt(nt) 
                      (
                        to,
                        (nt.right, s307) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s283
              case _: NonTerminal.Raw =>
                s237
              case _: NonTerminal.UnIgnoredElementList =>
                s111
              case _: NonTerminal.Element =>
                s272
              case _: NonTerminal.NonOptElement =>
                s197
              case _: NonTerminal.AnonList =>
                s245
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s308 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            308,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s309 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            309,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s248,
                        (tok.left, s309) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s36,
                        (tok.left, s309) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.listType =>
                      (
                        s268,
                        (tok.left, s309) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s137,
                        (tok.left, s309) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s274,
                        (tok.left, s309) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s309.onNt(nt) 
                      (
                        to,
                        (nt.right, s309) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s165
              case _: NonTerminal.Raw =>
                s166
              case _: NonTerminal.Element =>
                s42
              case _: NonTerminal.NonOptElement =>
                s260
              case _: NonTerminal.AnonList =>
                s88
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s310 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            310,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s44,
                        (tok.left, s310) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`)` =>
                      (
                        s66,
                        (tok.left, s310) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s311 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            311,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s65,
                        (tok.left, s311) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s251,
                        (tok.left, s311) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s63,
                        (tok.left, s311) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s311.onNt(nt) 
                      (
                        to,
                        (nt.right, s311) :: stack,
                        tokens.some,
                      ).left.some
                    case tok: Tok.listType =>
                      (
                        s200,
                        (tok.left, s311) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s215,
                        (tok.left, s311) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s54
              case _: NonTerminal.Raw =>
                s253
              case _: NonTerminal.Element =>
                s296
              case _: NonTerminal.NonOptElement =>
                s301
              case _: NonTerminal.AnonList =>
                s19
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s312 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            312,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s40,
                        (tok.left, s312) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s118,
                        (tok.left, s312) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s294,
                        (tok.left, s312) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s292,
                        (tok.left, s312) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s312.onNt(nt) 
                      (
                        to,
                        (nt.right, s312) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s236
              case _: NonTerminal.Raw =>
                s273
              case _: NonTerminal.UnIgnoredElementList =>
                s114
              case _: NonTerminal.Element =>
                s107
              case _: NonTerminal.NonOptElement =>
                s217
              case _: NonTerminal.AnonList =>
                s213
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s313 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            313,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s93,
                        (tok.left, s313) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s83,
                        (tok.left, s313) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s302,
                        (tok.left, s313) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s299,
                        (tok.left, s313) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s313.onNt(nt) 
                      (
                        to,
                        (nt.right, s313) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s283
              case _: NonTerminal.Raw =>
                s237
              case _: NonTerminal.UnIgnoredElementList =>
                s135
              case _: NonTerminal.Element =>
                s272
              case _: NonTerminal.NonOptElement =>
                s197
              case _: NonTerminal.AnonList =>
                s245
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s314 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            314,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s93,
                        (tok.left, s314) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.nonTerminal =>
                      (
                        s83,
                        (tok.left, s314) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`\"` =>
                      (
                        s302,
                        (tok.left, s314) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.terminal =>
                      (
                        s299,
                        (tok.left, s314) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      val to = s314.onNt(nt) 
                      (
                        to,
                        (nt.right, s314) :: stack,
                        tokens.some,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s283
              case _: NonTerminal.Raw =>
                s237
              case _: NonTerminal.UnIgnoredElementList =>
                s168
              case _: NonTerminal.Element =>
                s272
              case _: NonTerminal.NonOptElement =>
                s197
              case _: NonTerminal.AnonList =>
                s245
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s315 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            315,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          val to = poppedState.onNt(nt)
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            tokens.some,
                          ).left.some
                        case _ =>
                          None
                      }
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s316 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            316,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s4,
                        (tok.left, s316) :: stack,
                        tokens.tail.toNel,
                      ).left.some
                    case tok =>
                      None
                  }
                case None =>
                  None
              }
            },
            {
              case _ =>
                ??? // NOTE : This should not be possible...
            },
          )
        
        s230
      },
    )
  
}
// format: on
