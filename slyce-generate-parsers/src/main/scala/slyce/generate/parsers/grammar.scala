// !!! DO NOT MODIFY !!!
// File was automatically generated by slyce v0.1.0

package slyce.generate.parsers

// format: off

import scala.annotation.tailrec

import klib.Implicits._
import klib.fp.types._
import klib.utils._

import slyce.core._
import slyce.parse._

object grammar {
  
  sealed abstract class Tok(val tokName: String) extends Token
  object Tok {
    final case class assocType(text: String, span: Span) extends Tok("assocType")
    final case class chars(text: String, span: Span) extends Tok("chars") with NonTerminal.Char.LiftType
    final case class escChar(text: String, span: Span) extends Tok("escChar") with NonTerminal.Char.LiftType
    final case class listType(text: String, span: Span) extends Tok("listType")
    final case class mode(text: String, span: Span) extends Tok("mode")
    final case class nonTerminal(text: String, span: Span) extends Tok("nonTerminal") with NonTerminal.NonOptElement.LiftType
    final case class terminal(text: String, span: Span) extends Tok("terminal") with NonTerminal.NonOptElement.LiftType
    final case class tilde(text: String, span: Span) extends Tok("tilde")
    
    final case class `(`(text: String, span: Span) extends Tok(""""("""")
    final case class `)`(text: String, span: Span) extends Tok("""")"""")
    final case class `.`(text: String, span: Span) extends Tok(""""."""")
    final case class `:`(text: String, span: Span) extends Tok("""":"""")
    final case class `;`(text: String, span: Span) extends Tok("""";"""")
    final case class `?`(text: String, span: Span) extends Tok(""""?"""")
    final case class `@start:`(text: String, span: Span) extends Tok(""""@start:"""")
    final case class `\"`(text: String, span: Span) extends Tok(""""\""""")
    final case class `^`(text: String, span: Span) extends Tok(""""^"""")
    final case class `|`(text: String, span: Span) extends Tok(""""|"""")
    
    def findRawTerminal(text: String, span: Span): Attempt[Tok] =
      text match {
        case "(" => Tok.`(`(text, span).pure[Attempt]
        case ")" => Tok.`)`(text, span).pure[Attempt]
        case "." => Tok.`.`(text, span).pure[Attempt]
        case ":" => Tok.`:`(text, span).pure[Attempt]
        case ";" => Tok.`;`(text, span).pure[Attempt]
        case "?" => Tok.`?`(text, span).pure[Attempt]
        case "@start:" => Tok.`@start:`(text, span).pure[Attempt]
        case "\"" => Tok.`\"`(text, span).pure[Attempt]
        case "^" => Tok.`^`(text, span).pure[Attempt]
        case "|" => Tok.`|`(text, span).pure[Attempt]
        case _ => Dead(Marked(s"Invalid raw-terminal : ${text.unesc}", span.some) :: Nil)
      }
  }
  
  type NtRoot = NonTerminal.Grammar
  sealed trait NonTerminal
  object NonTerminal {
    type ElementList = ElementListSimple
    
    sealed trait AnonList extends NonTerminal with NonTerminal.NonOptElement.LiftType
    object AnonList {
      final case class _1(
        _0: NonTerminal.Element,
        _1: Tok.listType,
      ) extends AnonList
      final case class _2(
        _0: Tok.`(`,
        _1: NonTerminal.UnIgnoredElementList,
        _2: Tok.`)`,
        _3: Tok.listType,
      ) extends AnonList
      final case class _3(
        _0: Tok.`(`,
        _1: NonTerminal.UnIgnoredElementList,
        _2: Tok.`.`,
        _3: NonTerminal.UnIgnoredElementList,
        _4: Tok.`)`,
        _5: Tok.listType,
      ) extends AnonList
    }
    
    sealed trait AnonList10Tail extends NonTerminal
    object AnonList10Tail {
      final case class _1(
        _0: NonTerminal.Char,
        _1: NonTerminal.AnonList10Tail,
      ) extends AnonList10Tail
      case object _2 extends AnonList10Tail
    }
    
    final case class AnonList1Head(
      _0: NonTerminal.NT,
      _1: Tok.`;`,
      _2: NonTerminal.AnonList2Tail,
    ) extends NonTerminal {
      
      def toNonEmptyList: NonEmptyList[AnonList1Head.LiftType] = {
        @tailrec
        def loop(queue: AnonList2Tail, stack: List[AnonList1Head.LiftType]): List[AnonList1Head.LiftType] =
          queue match {
            case head: AnonList2Tail._1 => loop(head._2, head._0 :: stack)
            case _: AnonList2Tail._2.type => stack.reverse
          }
        
        NonEmptyList[AnonList1Head.LiftType](this._0, loop(this._2, Nil))
      }
      
    }
    object AnonList1Head {
      type LiftType = NonTerminal.NT
    }
    
    sealed trait AnonList2Tail extends NonTerminal
    object AnonList2Tail {
      final case class _1(
        _0: NonTerminal.NT,
        _1: Tok.`;`,
        _2: NonTerminal.AnonList2Tail,
      ) extends AnonList2Tail
      case object _2 extends AnonList2Tail
    }
    
    final case class AnonList3Head(
      _0: NonTerminal.ElementListSimple,
      _1: NonTerminal.AnonList4Tail,
    ) extends NonTerminal {
      
      def toNonEmptyList: NonEmptyList[AnonList3Head.LiftType] = {
        @tailrec
        def loop(queue: AnonList4Tail, stack: List[AnonList3Head.LiftType]): List[AnonList3Head.LiftType] =
          queue match {
            case head: AnonList4Tail._1 => loop(head._2, head._1 :: stack)
            case _: AnonList4Tail._2.type => stack.reverse
          }
        
        NonEmptyList[AnonList3Head.LiftType](this._0, loop(this._1, Nil))
      }
      
    }
    object AnonList3Head {
      type LiftType = NonTerminal.ElementList
    }
    
    sealed trait AnonList4Tail extends NonTerminal
    object AnonList4Tail {
      final case class _1(
        _0: Tok.`|`,
        _1: NonTerminal.ElementListSimple,
        _2: NonTerminal.AnonList4Tail,
      ) extends AnonList4Tail
      case object _2 extends AnonList4Tail
    }
    
    final case class AnonList5Head(
      _0: NonTerminal.UnIgnoredElementList,
      _1: NonTerminal.AnonList6Tail,
    ) extends NonTerminal {
      
      def toNonEmptyList: NonEmptyList[AnonList5Head.LiftType] = {
        @tailrec
        def loop(queue: AnonList6Tail, stack: List[AnonList5Head.LiftType]): List[AnonList5Head.LiftType] =
          queue match {
            case head: AnonList6Tail._1 => loop(head._2, head._1 :: stack)
            case _: AnonList6Tail._2.type => stack.reverse
          }
        
        NonEmptyList[AnonList5Head.LiftType](this._0, loop(this._1, Nil))
      }
      
    }
    object AnonList5Head {
      type LiftType = NonTerminal.UnIgnoredElementList
    }
    
    sealed trait AnonList6Tail extends NonTerminal
    object AnonList6Tail {
      final case class _1(
        _0: Tok.`|`,
        _1: NonTerminal.UnIgnoredElementList,
        _2: NonTerminal.AnonList6Tail,
      ) extends AnonList6Tail
      case object _2 extends AnonList6Tail
    }
    
    final case class AnonList7Head(
      _0: NonTerminal.AssocPair,
      _1: NonTerminal.AnonList8Tail,
    ) extends NonTerminal {
      
      def toNonEmptyList: NonEmptyList[AnonList7Head.LiftType] = {
        @tailrec
        def loop(queue: AnonList8Tail, stack: List[AnonList7Head.LiftType]): List[AnonList7Head.LiftType] =
          queue match {
            case head: AnonList8Tail._1 => loop(head._2, head._1 :: stack)
            case _: AnonList8Tail._2.type => stack.reverse
          }
        
        NonEmptyList[AnonList7Head.LiftType](this._0, loop(this._1, Nil))
      }
      
    }
    object AnonList7Head {
      type LiftType = NonTerminal.AssocPair
    }
    
    sealed trait AnonList8Tail extends NonTerminal
    object AnonList8Tail {
      final case class _1(
        _0: Tok.`|`,
        _1: NonTerminal.AssocPair,
        _2: NonTerminal.AnonList8Tail,
      ) extends AnonList8Tail
      case object _2 extends AnonList8Tail
    }
    
    final case class AnonList9Head(
      _0: NonTerminal.Char,
      _1: NonTerminal.AnonList10Tail,
    ) extends NonTerminal {
      
      def toNonEmptyList: NonEmptyList[AnonList9Head.LiftType] = {
        @tailrec
        def loop(queue: AnonList10Tail, stack: List[AnonList9Head.LiftType]): List[AnonList9Head.LiftType] =
          queue match {
            case head: AnonList10Tail._1 => loop(head._1, head._0 :: stack)
            case _: AnonList10Tail._2.type => stack.reverse
          }
        
        NonEmptyList[AnonList9Head.LiftType](this._0, loop(this._1, Nil))
      }
      
    }
    object AnonList9Head {
      type LiftType = NonTerminal.Char
    }
    
    final case class AssocNT(
      _0: Tok.tilde,
      _1: NonTerminal.AnonList7Head,
    ) extends NonTerminal with NonTerminal.NTBody.LiftType
    
    final case class AssocPair(
      _0: Tok.assocType,
      _1: NonTerminal.Element,
    ) extends NonTerminal
    
    final case class BasicNT(
      _0: Tok.`:`,
      _1: NonTerminal.AnonList3Head,
    ) extends NonTerminal with NonTerminal.StandardNT.LiftType
    
    sealed trait Char extends NonTerminal {
      
      def lift: Char.LiftType =
        this match {
          case nt: Char._1 => nt._0
          case nt: Char._2 => nt._0
        }
      
    }
    object Char {
      sealed trait LiftType
      
      final case class _1(
        _0: Tok.chars,
      ) extends Char
      final case class _2(
        _0: Tok.escChar,
      ) extends Char
    }
    
    final case class Element(
      _0: NonTerminal.NonOptElement,
      _1: NonTerminal.`Opt_?`,
    ) extends NonTerminal
    
    sealed trait ElementListSimple extends NonTerminal {
      
      def toList: List[ElementListSimple.LiftType] = {
        @tailrec
        def loop(queue: ElementListSimple, stack: List[ElementListSimple.LiftType]): List[ElementListSimple.LiftType] =
          queue match {
            case head: ElementListSimple._1 => loop(head._1, head._0 :: stack)
            case _: ElementListSimple._2.type => stack.reverse
          }
        
        loop(this, Nil)
      }
      
    }
    object ElementListSimple {
      type LiftType = NonTerminal.Element
      
      final case class _1(
        _0: NonTerminal.Element,
        _1: NonTerminal.ElementListSimple,
      ) extends ElementListSimple
      case object _2 extends ElementListSimple
    }
    
    final case class Grammar(
      _0: Tok.`@start:`,
      _1: Tok.mode,
      _2: NonTerminal.AnonList1Head,
    ) extends NonTerminal
    
    final case class LiftNT(
      _0: Tok.`^`,
      _1: NonTerminal.AnonList5Head,
    ) extends NonTerminal with NonTerminal.StandardNT.LiftType
    
    sealed trait ListNT extends NonTerminal with NonTerminal.NTBody.LiftType
    object ListNT {
      final case class _1(
        _0: Tok.listType,
        _1: NonTerminal.UnIgnoredElementList,
      ) extends ListNT
      final case class _2(
        _0: Tok.listType,
        _1: NonTerminal.UnIgnoredElementList,
        _2: Tok.`.`,
        _3: NonTerminal.UnIgnoredElementList,
      ) extends ListNT
    }
    
    final case class NT(
      _0: Tok.nonTerminal,
      _1: NonTerminal.NTBody,
    ) extends NonTerminal
    
    sealed trait NTBody extends NonTerminal {
      
      def lift: NTBody.LiftType =
        this match {
          case nt: NTBody._1 => nt._0
          case nt: NTBody._2 => nt._0
          case nt: NTBody._3 => nt._0
        }
      
    }
    object NTBody {
      sealed trait LiftType
      
      final case class _1(
        _0: NonTerminal.StandardNT,
      ) extends NTBody
      final case class _2(
        _0: NonTerminal.ListNT,
      ) extends NTBody
      final case class _3(
        _0: NonTerminal.AssocNT,
      ) extends NTBody
    }
    
    sealed trait NonOptElement extends NonTerminal {
      
      def lift: NonOptElement.LiftType =
        this match {
          case nt: NonOptElement._1 => nt._0
          case nt: NonOptElement._2 => nt._0
          case nt: NonOptElement._3 => nt._0
          case nt: NonOptElement._4 => nt._0
        }
      
    }
    object NonOptElement {
      sealed trait LiftType
      
      final case class _1(
        _0: Tok.nonTerminal,
      ) extends NonOptElement
      final case class _2(
        _0: Tok.terminal,
      ) extends NonOptElement
      final case class _3(
        _0: NonTerminal.Raw,
      ) extends NonOptElement
      final case class _4(
        _0: NonTerminal.AnonList,
      ) extends NonOptElement
    }
    
    final case class Raw(
      _0: Tok.`\"`,
      _1: NonTerminal.AnonList9Head,
      _2: Tok.`\"`,
    ) extends NonTerminal with NonTerminal.NonOptElement.LiftType
    
    sealed trait StandardNT extends NonTerminal with NonTerminal.NTBody.LiftType {
      
      def lift: StandardNT.LiftType =
        this match {
          case nt: StandardNT._1 => nt._0
          case nt: StandardNT._2 => nt._0
        }
      
    }
    object StandardNT {
      sealed trait LiftType
      
      final case class _1(
        _0: NonTerminal.BasicNT,
      ) extends StandardNT
      final case class _2(
        _0: NonTerminal.LiftNT,
      ) extends StandardNT
    }
    
    sealed trait UnIgnoredElementList extends NonTerminal
    object UnIgnoredElementList {
      final case class _1(
        _0: NonTerminal.Element,
      ) extends UnIgnoredElementList
      final case class _2(
        _0: NonTerminal.ElementListSimple,
        _1: Tok.`^`,
        _2: NonTerminal.Element,
        _3: NonTerminal.ElementListSimple,
      ) extends UnIgnoredElementList
    }
    
    sealed trait `Opt_?` extends NonTerminal {
      
      def toMaybe: Maybe[`Opt_?`.LiftType] =
        this match {
          case `Opt_?`._1(some) => some.some
          case `Opt_?`._2 => None
        }
      
    }
    object `Opt_?` {
      type LiftType = Tok.`?`
      
      final case class _1(
        _0: Tok.`?`,
      ) extends `Opt_?`
      case object _2 extends `Opt_?`
    }
    
  }
  
  lazy val parser: Parser[Tok, NonTerminal, NtRoot] =
    Parser[Tok, NonTerminal, NtRoot](
      Lexer[Tok] {
        var s12: Lexer.State[Tok] = null
        var s0: Lexer.State[Tok] = null
        var s1: Lexer.State[Tok] = null
        var s2: Lexer.State[Tok] = null
        var s3: Lexer.State[Tok] = null
        var s4: Lexer.State[Tok] = null
        var s5: Lexer.State[Tok] = null
        var s6: Lexer.State[Tok] = null
        var s7: Lexer.State[Tok] = null
        var s8: Lexer.State[Tok] = null
        var s9: Lexer.State[Tok] = null
        var s10: Lexer.State[Tok] = null
        var s11: Lexer.State[Tok] = null
        var s13: Lexer.State[Tok] = null
        var s14: Lexer.State[Tok] = null
        var s15: Lexer.State[Tok] = null
        var s16: Lexer.State[Tok] = null
        var s17: Lexer.State[Tok] = null
        var s18: Lexer.State[Tok] = null
        var s19: Lexer.State[Tok] = null
        var s20: Lexer.State[Tok] = null
        var s21: Lexer.State[Tok] = null
        var s22: Lexer.State[Tok] = null
        var s23: Lexer.State[Tok] = null
        var s24: Lexer.State[Tok] = null
        var s25: Lexer.State[Tok] = null
        var s26: Lexer.State[Tok] = null
        var s27: Lexer.State[Tok] = null
        var s28: Lexer.State[Tok] = null
        var s29: Lexer.State[Tok] = null
        var s30: Lexer.State[Tok] = null
        
        s12 =
          Lexer.State[Tok](
            12,
            char => {
              val int = char.toInt
              
              if (int == 64) // '@'
                s19.some
              else if (int == 34) // '\"'
                s4.some
              else if (int >= 97 && int <= 122) // 'a'-'z'
                s3.some
              else if (int >= 40 && int <= 41) // '('-')'
                s1.some
              else if (int == 46) // '.'
                s1.some
              else if (int >= 58 && int <= 59) // ':'-';'
                s1.some
              else if (int == 63) // '?'
                s1.some
              else if (int == 94) // '^'
                s1.some
              else if (int == 124) // '|'
                s1.some
              else if (int == 60) // '<'
                s5.some
              else if (int == 62) // '>'
                s5.some
              else if (int == 126) // '~'
                s25.some
              else if (int == 47) // '/'
                s11.some
              else if (int >= 9 && int <= 10) // '\t'-'\n'
                s8.some
              else if (int == 32) // ' '
                s8.some
              else if (int >= 65 && int <= 90) // 'A'-'Z'
                s24.some
              else if (int >= 42 && int <= 43) // '*'-'+'
                s9.some
              else
                None
            },
            None,
          )
        
        s0 =
          Lexer.State[Tok](
            0,
            _ => None,
            Lexer.Yields[Tok](
              List(
              ),
              Lexer.Yields.ToMode.Pop,
            ).some,
          )
        
        s1 =
          Lexer.State[Tok](
            1,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.findRawTerminal,
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s2 =
          Lexer.State[Tok](
            2,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (Some(1),Some(1)),
                  Tok.escChar(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s3 =
          Lexer.State[Tok](
            3,
            char => {
              val int = char.toInt
              
              if (int >= 48 && int <= 57) // '0'-'9'
                s3.some
              else if (int >= 65 && int <= 90) // 'A'-'Z'
                s3.some
              else if (int == 95) // '_'
                s3.some
              else if (int >= 97 && int <= 122) // 'a'-'z'
                s3.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.terminal(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s4 =
          Lexer.State[Tok](
            4,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.findRawTerminal,
                ),
              ),
              Lexer.Yields.ToMode.Push[Tok](Lazy(s29)),
            ).some,
          )
        
        s5 =
          Lexer.State[Tok](
            5,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.assocType(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s6 =
          Lexer.State[Tok](
            6,
            _ => None,
            Lexer.Yields[Tok](
              List(
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s7 =
          Lexer.State[Tok](
            7,
            char => {
              val int = char.toInt
              
              if (int == 42) // '*'
                s21.some
              else
                s7.some
            },
            None,
          )
        
        s8 =
          Lexer.State[Tok](
            8,
            char => {
              val int = char.toInt
              
              if (int >= 9 && int <= 10) // '\t'-'\n'
                s8.some
              else if (int == 32) // ' '
                s8.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s9 =
          Lexer.State[Tok](
            9,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.listType(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s10 =
          Lexer.State[Tok](
            10,
            char => {
              val int = char.toInt
              
              if (int >= 48 && int <= 57) // '0'-'9'
                s10.some
              else if (int >= 65 && int <= 90) // 'A'-'Z'
                s10.some
              else if (int == 95) // '_'
                s10.some
              else if (int >= 97 && int <= 122) // 'a'-'z'
                s10.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.mode(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s11 =
          Lexer.State[Tok](
            11,
            char => {
              val int = char.toInt
              
              if (int == 42) // '*'
                s7.some
              else if (int == 47) // '/'
                s16.some
              else
                None
            },
            None,
          )
        
        s13 =
          Lexer.State[Tok](
            13,
            char => {
              val int = char.toInt
              
              if (int == 34) // '\"'
                None
              else if (int == 92) // '\\'
                None
              else
                s13.some
            },
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.chars(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s14 =
          Lexer.State[Tok](
            14,
            char => {
              val int = char.toInt
              
              if (int == 97) // 'a'
                s28.some
              else
                None
            },
            None,
          )
        
        s15 =
          Lexer.State[Tok](
            15,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.findRawTerminal,
                ),
              ),
              Lexer.Yields.ToMode.Pop,
            ).some,
          )
        
        s16 =
          Lexer.State[Tok](
            16,
            char => {
              val int = char.toInt
              
              if (int == 10) // '\n'
                s6.some
              else
                s16.some
            },
            None,
          )
        
        s17 =
          Lexer.State[Tok](
            17,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.findRawTerminal,
                ),
              ),
              Lexer.Yields.ToMode.Push[Tok](Lazy(s22)),
            ).some,
          )
        
        s18 =
          Lexer.State[Tok](
            18,
            _ => None,
            Lexer.Yields[Tok](
              List(
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s19 =
          Lexer.State[Tok](
            19,
            char => {
              val int = char.toInt
              
              if (int == 115) // 's'
                s23.some
              else
                None
            },
            None,
          )
        
        s20 =
          Lexer.State[Tok](
            20,
            char => {
              val int = char.toInt
              
              if (int == 9) // '\t'
                s20.some
              else if (int == 32) // ' '
                s20.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s21 =
          Lexer.State[Tok](
            21,
            char => {
              val int = char.toInt
              
              if (int == 47) // '/'
                s18.some
              else
                s7.some
            },
            None,
          )
        
        s22 =
          Lexer.State[Tok](
            22,
            char => {
              val int = char.toInt
              
              if (int >= 65 && int <= 90) // 'A'-'Z'
                s10.some
              else if (int == 10) // '\n'
                s0.some
              else if (int == 9) // '\t'
                s20.some
              else if (int == 32) // ' '
                s20.some
              else
                None
            },
            None,
          )
        
        s23 =
          Lexer.State[Tok](
            23,
            char => {
              val int = char.toInt
              
              if (int == 116) // 't'
                s14.some
              else
                None
            },
            None,
          )
        
        s24 =
          Lexer.State[Tok](
            24,
            char => {
              val int = char.toInt
              
              if (int >= 48 && int <= 57) // '0'-'9'
                s24.some
              else if (int >= 65 && int <= 90) // 'A'-'Z'
                s24.some
              else if (int == 95) // '_'
                s24.some
              else if (int >= 97 && int <= 122) // 'a'-'z'
                s24.some
              else
                None
            },
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.nonTerminal(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s25 =
          Lexer.State[Tok](
            25,
            _ => None,
            Lexer.Yields[Tok](
              List(
                Lexer.Yields.Yield[Tok](
                  (None,None),
                  Tok.tilde(_, _).pure[Attempt]
                ),
              ),
              Lexer.Yields.ToMode.Same,
            ).some,
          )
        
        s26 =
          Lexer.State[Tok](
            26,
            char => {
              val int = char.toInt
              
              if (int == 58) // ':'
                s17.some
              else
                None
            },
            None,
          )
        
        s27 =
          Lexer.State[Tok](
            27,
            char => {
              val int = char.toInt
              
              if (int == 34) // '\"'
                s2.some
              else if (int == 92) // '\\'
                s2.some
              else if (int == 110) // 'n'
                s2.some
              else if (int == 116) // 't'
                s2.some
              else
                None
            },
            None,
          )
        
        s28 =
          Lexer.State[Tok](
            28,
            char => {
              val int = char.toInt
              
              if (int == 114) // 'r'
                s30.some
              else
                None
            },
            None,
          )
        
        s29 =
          Lexer.State[Tok](
            29,
            char => {
              val int = char.toInt
              
              if (int == 92) // '\\'
                s27.some
              else if (int == 34) // '\"'
                s15.some
              else
                s13.some
            },
            None,
          )
        
        s30 =
          Lexer.State[Tok](
            30,
            char => {
              val int = char.toInt
              
              if (int == 116) // 't'
                s26.some
              else
                None
            },
            None,
          )
        
        
        s12
      },
      Grammar[Tok, NonTerminal, NtRoot] {
        var s0: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s1: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s2: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s3: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s4: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s5: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s6: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s7: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s8: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s9: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s10: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s11: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s12: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s13: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s14: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s15: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s16: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s17: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s18: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s19: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s20: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s21: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s22: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s23: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s24: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s25: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s26: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s27: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s28: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s29: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s30: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s31: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s32: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s33: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s34: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s35: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s36: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s37: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s38: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s39: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s40: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s41: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s42: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s43: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s44: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s45: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s46: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s47: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s48: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s49: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s50: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s51: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s52: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s53: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s54: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s55: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s56: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s57: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s58: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s59: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s60: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s61: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s62: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s63: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s64: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s65: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s66: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s67: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s68: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s69: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s70: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s71: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s72: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s73: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s74: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s75: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s76: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s77: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s78: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s79: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s80: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s81: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s82: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s83: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s84: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s85: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s86: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s87: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s88: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s89: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s90: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s91: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s92: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s93: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s94: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s95: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s96: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s97: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s98: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s99: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s100: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s101: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s102: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s103: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s104: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s105: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s106: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s107: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s108: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s109: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s110: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s111: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s112: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s113: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s114: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s115: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s116: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s117: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s118: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s119: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s120: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s121: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s122: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s123: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s124: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s125: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s126: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s127: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s128: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s129: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s130: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s131: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s132: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s133: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s134: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s135: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s136: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s137: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s138: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s139: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s140: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s141: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s142: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s143: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s144: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s145: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s146: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s147: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s148: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s149: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s150: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s151: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s152: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s153: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s154: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s155: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s156: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s157: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s158: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s159: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s160: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s161: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s162: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s163: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s164: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s165: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s166: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s167: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s168: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s169: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s170: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s171: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s172: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s173: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s174: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s175: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s176: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s177: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s178: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s179: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s180: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s181: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s182: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s183: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s184: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s185: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s186: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s187: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s188: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s189: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s190: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s191: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s192: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s193: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s194: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s195: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s196: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s197: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s198: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s199: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s200: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s201: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s202: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s203: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s204: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s205: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s206: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s207: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s208: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s209: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s210: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s211: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s212: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s213: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s214: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s215: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s216: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s217: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s218: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s219: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s220: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s221: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s222: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s223: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s224: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s225: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s226: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s227: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s228: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s229: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s230: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s231: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s232: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s233: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s234: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s235: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s236: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s237: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s238: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s239: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s240: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s241: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s242: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s243: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s244: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s245: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s246: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s247: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s248: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s249: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s250: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s251: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s252: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s253: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s254: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s255: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s256: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s257: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s258: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s259: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s260: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s261: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s262: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s263: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s264: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s265: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s266: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s267: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s268: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s269: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s270: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s271: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s272: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s273: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s274: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s275: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s276: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s277: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s278: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s279: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s280: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s281: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s282: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s283: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s284: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s285: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s286: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s287: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s288: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s289: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s290: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s291: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s292: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s293: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s294: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s295: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s296: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s297: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s298: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s299: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s300: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s301: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s302: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s303: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s304: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s305: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s306: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s307: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s308: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s309: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s310: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s311: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s312: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s313: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s314: Grammar.State[Tok, NonTerminal, NtRoot] = null
        var s315: Grammar.State[Tok, NonTerminal, NtRoot] = null
        
        s0 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            0,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s1 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            1,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.NTBody), _) :: (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NT(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.NTBody), _) :: (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s2 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            2,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s32,
                        (tok.left, s2) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s111,
                        (tok.left, s2) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s277,
                        (tok.left, s2) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s298,
                        (tok.left, s2) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s2.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s2) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s228.pure[Attempt]
              case _: NonTerminal.Raw =>
                s270.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s27.pure[Attempt]
              case _: NonTerminal.Element =>
                s282.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s204.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s200.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s3 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            3,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      (
                        s271,
                        (tok.left, s3) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s4 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            4,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s257,
                        (tok.left, s4) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`)` =>
                      (
                        s28,
                        (tok.left, s4) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s5 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            5,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s237,
                        (tok.left, s5) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s75,
                        (tok.left, s5) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s125,
                        (tok.left, s5) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s302,
                        (tok.left, s5) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s5.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s5) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s284.pure[Attempt]
              case _: NonTerminal.Raw =>
                s236.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s157.pure[Attempt]
              case _: NonTerminal.Element =>
                s308.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s182.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s241.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s6 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            6,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s198,
                        (tok.left, s6) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.chars =>
                      (
                        s138,
                        (tok.left, s6) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.Char =>
                s116.pure[Attempt]
              case _: NonTerminal.AnonList9Head =>
                s225.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s7 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            7,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s8 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            8,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s237,
                        (tok.left, s8) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s75,
                        (tok.left, s8) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s125,
                        (tok.left, s8) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s302,
                        (tok.left, s8) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s8.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s8) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s284.pure[Attempt]
              case _: NonTerminal.Raw =>
                s236.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s240.pure[Attempt]
              case _: NonTerminal.Element =>
                s308.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s182.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s241.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s9 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            9,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList8Tail), _) :: (Right(_1: NonTerminal.AssocPair), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList7Head(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.AnonList8Tail), _) :: (Right(_1: NonTerminal.AssocPair), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s10 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            10,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s11 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            11,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      (
                        s41,
                        (tok.left, s11) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s11.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s11) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.nonTerminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s11.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s11) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.listType =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s11.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s11) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s11.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s11) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.terminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s11.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s11) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s11.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s11) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s11.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s11) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s11.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s11) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.`Opt_?` =>
                s81.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s12 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            12,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s198,
                        (tok.left, s12) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.chars =>
                      (
                        s138,
                        (tok.left, s12) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.Char =>
                s116.pure[Attempt]
              case _: NonTerminal.AnonList9Head =>
                s285.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s13 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            13,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s14 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            14,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      (
                        s192,
                        (tok.left, s14) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s15 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            15,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s120,
                        (tok.left, s15) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s104,
                        (tok.left, s15) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s127,
                        (tok.left, s15) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s206,
                        (tok.left, s15) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s15.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s15) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s15.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s15) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s70.pure[Attempt]
              case _: NonTerminal.Raw =>
                s172.pure[Attempt]
              case _: NonTerminal.Element =>
                s45.pure[Attempt]
              case _: NonTerminal.AnonList3Head =>
                s90.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s74.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s188.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s16 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            16,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s17 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            17,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s198,
                        (tok.left, s17) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.chars =>
                      (
                        s138,
                        (tok.left, s17) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.Char =>
                s116.pure[Attempt]
              case _: NonTerminal.AnonList9Head =>
                s230.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s18 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            18,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      (
                        s162,
                        (tok.left, s18) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s19 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            19,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s67,
                        (tok.left, s19) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s20 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            20,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s21 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            21,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ElementListSimple._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ElementListSimple._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s22 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            22,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s23 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            23,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s23.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s23) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`?` =>
                      (
                        s33,
                        (tok.left, s23) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s23.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s23) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.nonTerminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s23.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s23) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.terminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s23.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s23) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s23.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s23) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.listType =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s23.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s23) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s23.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s23) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.`Opt_?` =>
                s185.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s24 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            24,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s77,
                        (tok.left, s24) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s25 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            25,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s181,
                        (tok.left, s25) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s93,
                        (tok.left, s25) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s133,
                        (tok.left, s25) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s218,
                        (tok.left, s25) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.NonOptElement =>
                s50.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s54.pure[Attempt]
              case _: NonTerminal.Raw =>
                s68.pure[Attempt]
              case _: NonTerminal.Element =>
                s250.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s26 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            26,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s95,
                        (tok.left, s26) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s27 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            27,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s66,
                        (tok.left, s27) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`)` =>
                      (
                        s160,
                        (tok.left, s27) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s28 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            28,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s219,
                        (tok.left, s28) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s29 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            29,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      (
                        s227,
                        (tok.left, s29) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s30 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            30,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_3: NonTerminal.AnonList8Tail), _) :: (Right(_2: NonTerminal.AssocPair), _) :: (Left(_1: Tok.`|`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList8Tail._1(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_3: NonTerminal.AnonList8Tail), _) :: (Right(_2: NonTerminal.AssocPair), _) :: (Left(_1: Tok.`|`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s31 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            31,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.assocType =>
                      (
                        s174,
                        (tok.left, s31) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.AssocPair =>
                s287.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s32 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            32,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s32,
                        (tok.left, s32) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s111,
                        (tok.left, s32) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s277,
                        (tok.left, s32) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s298,
                        (tok.left, s32) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s32.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s32) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s228.pure[Attempt]
              case _: NonTerminal.Raw =>
                s270.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s4.pure[Attempt]
              case _: NonTerminal.Element =>
                s282.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s204.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s200.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s33 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            33,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s34 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            34,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s198,
                        (tok.left, s34) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.chars =>
                      (
                        s138,
                        (tok.left, s34) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.Char =>
                s116.pure[Attempt]
              case _: NonTerminal.AnonList9Head =>
                s14.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s35 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            35,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s36 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            36,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s37 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            37,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.assocType =>
                      (
                        s174,
                        (tok.left, s37) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.AnonList7Head =>
                s278.pure[Attempt]
              case _: NonTerminal.AssocPair =>
                s194.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s38 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            38,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s39 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            39,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s40 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            40,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s41 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            41,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s42 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            42,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_4: NonTerminal.ElementListSimple), _) :: (Right(_3: NonTerminal.Element), _) :: (Left(_2: Tok.`^`), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_4: NonTerminal.ElementListSimple), _) :: (Right(_3: NonTerminal.Element), _) :: (Left(_2: Tok.`^`), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s43 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            43,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s44 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            44,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s32,
                        (tok.left, s44) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s111,
                        (tok.left, s44) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s277,
                        (tok.left, s44) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s298,
                        (tok.left, s44) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s44.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s44) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s228.pure[Attempt]
              case _: NonTerminal.Raw =>
                s270.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s126.pure[Attempt]
              case _: NonTerminal.Element =>
                s282.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s204.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s200.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s45 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            45,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s120,
                        (tok.left, s45) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s104,
                        (tok.left, s45) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s127,
                        (tok.left, s45) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.listType =>
                      (
                        s146,
                        (tok.left, s45) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s206,
                        (tok.left, s45) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s45.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s45) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s45.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s45) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s21.pure[Attempt]
              case _: NonTerminal.Raw =>
                s172.pure[Attempt]
              case _: NonTerminal.Element =>
                s45.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s74.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s188.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s46 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            46,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s44,
                        (tok.left, s46) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s35,
                        (tok.left, s46) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.listType =>
                      (
                        s266,
                        (tok.left, s46) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s17,
                        (tok.left, s46) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s272,
                        (tok.left, s46) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s46.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s46) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s155.pure[Attempt]
              case _: NonTerminal.Raw =>
                s156.pure[Attempt]
              case _: NonTerminal.Element =>
                s290.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s258.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s82.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s47 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            47,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s309,
                        (tok.left, s47) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s48 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            48,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s49 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            49,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s43,
                        (tok.left, s49) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s50 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            50,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      (
                        s255,
                        (tok.left, s50) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s50.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s50) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.terminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s50.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s50) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.listType =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s50.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s50) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s50.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s50) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`)` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s50.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s50) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s50.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s50) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.`Opt_?` =>
                s13.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s51 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            51,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s2,
                        (tok.left, s51) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s69,
                        (tok.left, s51) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s312,
                        (tok.left, s51) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s261,
                        (tok.left, s51) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s51.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s51) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s279.pure[Attempt]
              case _: NonTerminal.Raw =>
                s145.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s94.pure[Attempt]
              case _: NonTerminal.Element =>
                s176.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s168.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s65.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s52 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            52,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s52.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s52) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.nonTerminal =>
                      (
                        s191,
                        (tok.left, s52) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s140,
                        (tok.left, s52) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.listType =>
                      (
                        s107,
                        (tok.left, s52) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s131,
                        (tok.left, s52) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`)` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s52.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s52) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`(` =>
                      (
                        s202,
                        (tok.left, s52) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s151.pure[Attempt]
              case _: NonTerminal.Raw =>
                s253.pure[Attempt]
              case _: NonTerminal.Element =>
                s269.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s196.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s129.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s53 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            53,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s32,
                        (tok.left, s53) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s111,
                        (tok.left, s53) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s277,
                        (tok.left, s53) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s298,
                        (tok.left, s53) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s53.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s53) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s228.pure[Attempt]
              case _: NonTerminal.Raw =>
                s270.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s243.pure[Attempt]
              case _: NonTerminal.Element =>
                s282.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s204.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s200.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s54 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            54,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s55 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            55,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s83,
                        (tok.left, s55) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s247,
                        (tok.left, s55) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s246,
                        (tok.left, s55) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s56,
                        (tok.left, s55) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.NonOptElement =>
                s304.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s22.pure[Attempt]
              case _: NonTerminal.Raw =>
                s242.pure[Attempt]
              case _: NonTerminal.Element =>
                s301.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s56 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            56,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s57 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            57,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_3: NonTerminal.AnonList4Tail), _) :: (Right(_2: NonTerminal.ElementListSimple), _) :: (Left(_1: Tok.`|`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList4Tail._1(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_3: NonTerminal.AnonList4Tail), _) :: (Right(_2: NonTerminal.ElementListSimple), _) :: (Left(_1: Tok.`|`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s58 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            58,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s92,
                        (tok.left, s58) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s59 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            59,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s36,
                        (tok.left, s59) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s60 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            60,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s83,
                        (tok.left, s60) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s247,
                        (tok.left, s60) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s56,
                        (tok.left, s60) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s60.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s60) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.listType =>
                      (
                        s187,
                        (tok.left, s60) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s246,
                        (tok.left, s60) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s96.pure[Attempt]
              case _: NonTerminal.Raw =>
                s242.pure[Attempt]
              case _: NonTerminal.Element =>
                s60.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s304.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s22.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s61 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            61,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s62 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            62,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  stack match {
                    case (Right(_3: NonTerminal.AnonList2Tail), _) :: (Left(_2: Tok.`;`), _) :: (Right(_1: NonTerminal.NT), poppedState) :: stack =>
                      val nt: NonTerminal = NonTerminal.AnonList1Head(_1, _2, _3)
                      poppedState.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            None,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case _ =>
                      Dead(Marked("This should be impossible (1)... (Right(_3: NonTerminal.AnonList2Tail), _) :: (Left(_2: Tok.`;`), _) :: (Right(_1: NonTerminal.NT), poppedState)") :: Nil)
                  }
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s63 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            63,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s202,
                        (tok.left, s63) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s191,
                        (tok.left, s63) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s131,
                        (tok.left, s63) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s140,
                        (tok.left, s63) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.NonOptElement =>
                s196.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s129.pure[Attempt]
              case _: NonTerminal.Raw =>
                s253.pure[Attempt]
              case _: NonTerminal.Element =>
                s52.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s64 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            64,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s65 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            65,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s66 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            66,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s237,
                        (tok.left, s66) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s75,
                        (tok.left, s66) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s125,
                        (tok.left, s66) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s302,
                        (tok.left, s66) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s66.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s66) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s284.pure[Attempt]
              case _: NonTerminal.Raw =>
                s236.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s288.pure[Attempt]
              case _: NonTerminal.Element =>
                s308.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s182.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s241.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s67 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            67,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s249,
                        (tok.left, s67) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s68 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            68,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s69 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            69,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s70 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            70,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.AnonList4Tail._2
                      s70.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s70) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`|` =>
                      (
                        s217,
                        (tok.left, s70) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.AnonList4Tail =>
                s122.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s71 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            71,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s72 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            72,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.BasicNT), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.StandardNT._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.BasicNT), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s73 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            73,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.Element), _) :: (Left(_1: Tok.assocType), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AssocPair(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.Element), _) :: (Left(_1: Tok.assocType), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_2: NonTerminal.Element), _) :: (Left(_1: Tok.assocType), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AssocPair(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.Element), _) :: (Left(_1: Tok.assocType), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      (
                        s254,
                        (tok.left, s73) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s74 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            74,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      (
                        s80,
                        (tok.left, s74) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s74.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s74) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.nonTerminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s74.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s74) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.terminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s74.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s74) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.listType =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s74.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s74) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s74.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s74) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s74.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s74) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s74.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s74) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.`Opt_?` =>
                s112.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s75 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            75,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s76 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            76,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s77 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            77,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s78 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            78,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s79 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            79,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s79.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s79) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`?` =>
                      (
                        s39,
                        (tok.left, s79) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s79.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s79) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.listType =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s79.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s79) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.`Opt_?` =>
                s163.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s80 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            80,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s81 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            81,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s82 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            82,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s83 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            83,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s32,
                        (tok.left, s83) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s111,
                        (tok.left, s83) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s277,
                        (tok.left, s83) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s298,
                        (tok.left, s83) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s83.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s83) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s228.pure[Attempt]
              case _: NonTerminal.Raw =>
                s270.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s134.pure[Attempt]
              case _: NonTerminal.Element =>
                s282.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s204.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s200.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s84 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            84,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s84.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s84) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`(` =>
                      (
                        s53,
                        (tok.left, s84) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s245,
                        (tok.left, s84) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s109,
                        (tok.left, s84) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s84.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s84) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.listType =>
                      (
                        s199,
                        (tok.left, s84) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s34,
                        (tok.left, s84) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s142.pure[Attempt]
              case _: NonTerminal.Raw =>
                s113.pure[Attempt]
              case _: NonTerminal.Element =>
                s84.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s23.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s154.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s85 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            85,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`^` =>
                      (
                        s102,
                        (tok.left, s85) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s86 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            86,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s178,
                        (tok.left, s86) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s87 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            87,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s88 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            88,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.mode =>
                      (
                        s165,
                        (tok.left, s88) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s89 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            89,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s211,
                        (tok.left, s89) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s90 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            90,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList3Head), _) :: (Left(_1: Tok.`:`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.BasicNT(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.AnonList3Head), _) :: (Left(_1: Tok.`:`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s91 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            91,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s92 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            92,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s93 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            93,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s94 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            94,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.listType), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ListNT._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.listType), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s95 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            95,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s96 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            96,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ElementListSimple._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s97 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            97,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      (
                        s232,
                        (tok.left, s97) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s98 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            98,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s222,
                        (tok.left, s98) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s16,
                        (tok.left, s98) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s6,
                        (tok.left, s98) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s289,
                        (tok.left, s98) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s98.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s98) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s292.pure[Attempt]
              case _: NonTerminal.Raw =>
                s106.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s201.pure[Attempt]
              case _: NonTerminal.Element =>
                s46.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s11.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s171.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s99 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            99,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s99.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s99) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`?` =>
                      (
                        s195,
                        (tok.left, s99) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s99.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s99) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.nonTerminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s99.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s99) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s99.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s99) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.listType =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s99.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s99) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s99.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s99) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.terminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s99.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s99) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s99.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s99) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.`Opt_?` =>
                s275.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s100 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            100,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_4: NonTerminal.ElementListSimple), _) :: (Right(_3: NonTerminal.Element), _) :: (Left(_2: Tok.`^`), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_4: NonTerminal.ElementListSimple), _) :: (Right(_3: NonTerminal.Element), _) :: (Left(_2: Tok.`^`), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_4: NonTerminal.ElementListSimple), _) :: (Right(_3: NonTerminal.Element), _) :: (Left(_2: Tok.`^`), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_4: NonTerminal.ElementListSimple), _) :: (Right(_3: NonTerminal.Element), _) :: (Left(_2: Tok.`^`), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s101 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            101,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s205,
                        (tok.left, s101) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s38,
                        (tok.left, s101) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s12,
                        (tok.left, s101) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s78,
                        (tok.left, s101) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s101.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s101) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s85.pure[Attempt]
              case _: NonTerminal.Raw =>
                s224.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s303.pure[Attempt]
              case _: NonTerminal.Element =>
                s161.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s99.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s150.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s102 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            102,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s53,
                        (tok.left, s102) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s245,
                        (tok.left, s102) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s34,
                        (tok.left, s102) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s109,
                        (tok.left, s102) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.NonOptElement =>
                s23.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s154.pure[Attempt]
              case _: NonTerminal.Raw =>
                s113.pure[Attempt]
              case _: NonTerminal.Element =>
                s264.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s103 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            103,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      (
                        s239,
                        (tok.left, s103) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s104 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            104,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s105 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            105,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s106 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            106,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s107 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            107,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s108 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            108,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s5,
                        (tok.left, s108) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`)` =>
                      (
                        s209,
                        (tok.left, s108) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s109 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            109,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s110 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            110,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  stack match {
                    case (Right(ntRoot: NtRoot), _) :: Nil =>
                      ntRoot.right.pure[Attempt]
                    case _ =>
                      Dead(Marked("This should be impossible (2)...") :: Nil)
                  }
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s111 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            111,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s112 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            112,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s113 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            113,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s114 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            114,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s293,
                        (tok.left, s114) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s115 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            115,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s237,
                        (tok.left, s115) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s75,
                        (tok.left, s115) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s125,
                        (tok.left, s115) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s302,
                        (tok.left, s115) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s115.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s115) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s284.pure[Attempt]
              case _: NonTerminal.Raw =>
                s236.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s136.pure[Attempt]
              case _: NonTerminal.Element =>
                s308.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s182.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s241.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s116 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            116,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s198,
                        (tok.left, s116) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.chars =>
                      (
                        s138,
                        (tok.left, s116) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.AnonList10Tail._2
                      s116.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s116) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.Char =>
                s148.pure[Attempt]
              case _: NonTerminal.AnonList10Tail =>
                s263.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s117 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            117,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.nonTerminal =>
                      (
                        s141,
                        (tok.left, s117) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  val nt: NonTerminal = NonTerminal.AnonList2Tail._2
                  s117.onNt(nt) match {
                    case Alive(to) =>
                      (
                        to,
                        (nt.right, s117) :: stack,
                        None,
                      ).left.pure[Attempt]
                    case dead @ Dead(_) =>
                      dead
                  }
              }
            },
            {
              case _: NonTerminal.NT =>
                s297.pure[Attempt]
              case _: NonTerminal.AnonList2Tail =>
                s62.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s118 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            118,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.LiftNT), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.StandardNT._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.LiftNT), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s119 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            119,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s173,
                        (tok.left, s119) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s120 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            120,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s32,
                        (tok.left, s120) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s111,
                        (tok.left, s120) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s277,
                        (tok.left, s120) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s298,
                        (tok.left, s120) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s120.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s120) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s228.pure[Attempt]
              case _: NonTerminal.Raw =>
                s270.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s108.pure[Attempt]
              case _: NonTerminal.Element =>
                s282.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s204.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s200.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s121 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            121,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_4: NonTerminal.ElementListSimple), _) :: (Right(_3: NonTerminal.Element), _) :: (Left(_2: Tok.`^`), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_4: NonTerminal.ElementListSimple), _) :: (Right(_3: NonTerminal.Element), _) :: (Left(_2: Tok.`^`), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s122 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            122,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList4Tail), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList3Head(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.AnonList4Tail), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s123 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            123,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s238,
                        (tok.left, s123) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s124 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            124,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList6Tail), _) :: (Right(_1: NonTerminal.UnIgnoredElementList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList5Head(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.AnonList6Tail), _) :: (Right(_1: NonTerminal.UnIgnoredElementList), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s125 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            125,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s198,
                        (tok.left, s125) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.chars =>
                      (
                        s138,
                        (tok.left, s125) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.Char =>
                s116.pure[Attempt]
              case _: NonTerminal.AnonList9Head =>
                s97.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s126 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            126,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s213,
                        (tok.left, s126) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`)` =>
                      (
                        s186,
                        (tok.left, s126) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s127 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            127,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s128 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            128,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.StandardNT), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NTBody._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.StandardNT), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s129 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            129,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s130 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            130,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s20,
                        (tok.left, s130) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s131 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            131,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s198,
                        (tok.left, s131) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.chars =>
                      (
                        s138,
                        (tok.left, s131) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.Char =>
                s116.pure[Attempt]
              case _: NonTerminal.AnonList9Head =>
                s103.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s132 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            132,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s133 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            133,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s198,
                        (tok.left, s133) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.chars =>
                      (
                        s138,
                        (tok.left, s133) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.Char =>
                s116.pure[Attempt]
              case _: NonTerminal.AnonList9Head =>
                s280.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s134 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            134,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s115,
                        (tok.left, s134) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`)` =>
                      (
                        s233,
                        (tok.left, s134) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s135 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            135,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList10Tail), _) :: (Right(_1: NonTerminal.Char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList10Tail._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.AnonList10Tail), _) :: (Right(_1: NonTerminal.Char), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s136 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            136,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s86,
                        (tok.left, s136) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s137 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            137,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s138 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            138,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_1: Tok.chars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Char._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.chars), poppedState)") :: Nil)
                      }
                    case tok: Tok.chars =>
                      stack match {
                        case (Left(_1: Tok.chars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Char._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.chars), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.chars), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Char._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.chars), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s139 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            139,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s190,
                        (tok.left, s139) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`)` =>
                      (
                        s24,
                        (tok.left, s139) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s140 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            140,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s141 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            141,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`^` =>
                      (
                        s175,
                        (tok.left, s141) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.tilde =>
                      (
                        s37,
                        (tok.left, s141) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`:` =>
                      (
                        s15,
                        (tok.left, s141) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.listType =>
                      (
                        s101,
                        (tok.left, s141) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.BasicNT =>
                s72.pure[Attempt]
              case _: NonTerminal.AssocNT =>
                s286.pure[Attempt]
              case _: NonTerminal.StandardNT =>
                s128.pure[Attempt]
              case _: NonTerminal.ListNT =>
                s234.pure[Attempt]
              case _: NonTerminal.LiftNT =>
                s118.pure[Attempt]
              case _: NonTerminal.NTBody =>
                s1.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s142 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            142,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ElementListSimple._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ElementListSimple._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s143 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            143,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.nonTerminal =>
                      (
                        s93,
                        (tok.left, s143) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s218,
                        (tok.left, s143) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.listType =>
                      (
                        s167,
                        (tok.left, s143) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s133,
                        (tok.left, s143) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`)` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s143.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s143) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`(` =>
                      (
                        s181,
                        (tok.left, s143) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s306.pure[Attempt]
              case _: NonTerminal.Raw =>
                s68.pure[Attempt]
              case _: NonTerminal.Element =>
                s143.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s50.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s54.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s144 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            144,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s145 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            145,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s146 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            146,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s147 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            147,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s148 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            148,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s198,
                        (tok.left, s148) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.chars =>
                      (
                        s138,
                        (tok.left, s148) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.AnonList10Tail._2
                      s148.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s148) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.Char =>
                s148.pure[Attempt]
              case _: NonTerminal.AnonList10Tail =>
                s135.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s149 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            149,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s203,
                        (tok.left, s149) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s150 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            150,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s151 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            151,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_4: NonTerminal.ElementListSimple), _) :: (Right(_3: NonTerminal.Element), _) :: (Left(_2: Tok.`^`), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_4: NonTerminal.ElementListSimple), _) :: (Right(_3: NonTerminal.Element), _) :: (Left(_2: Tok.`^`), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_4: NonTerminal.ElementListSimple), _) :: (Right(_3: NonTerminal.Element), _) :: (Left(_2: Tok.`^`), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_4: NonTerminal.ElementListSimple), _) :: (Right(_3: NonTerminal.Element), _) :: (Left(_2: Tok.`^`), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s152 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            152,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s198,
                        (tok.left, s152) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.chars =>
                      (
                        s138,
                        (tok.left, s152) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.Char =>
                s116.pure[Attempt]
              case _: NonTerminal.AnonList9Head =>
                s3.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s153 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            153,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s207,
                        (tok.left, s153) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s154 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            154,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s155 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            155,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ElementListSimple._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s156 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            156,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s157 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            157,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s58,
                        (tok.left, s157) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s158 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            158,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s159 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            159,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s160 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            160,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s137,
                        (tok.left, s160) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s161 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            161,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      (
                        s44,
                        (tok.left, s161) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s35,
                        (tok.left, s161) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      (
                        s48,
                        (tok.left, s161) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s17,
                        (tok.left, s161) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s272,
                        (tok.left, s161) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s161.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s161) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s155.pure[Attempt]
              case _: NonTerminal.Raw =>
                s156.pure[Attempt]
              case _: NonTerminal.Element =>
                s290.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s258.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s82.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s162 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            162,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s163 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            163,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s164 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            164,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s165 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            165,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.nonTerminal =>
                      (
                        s141,
                        (tok.left, s165) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.AnonList1Head =>
                s273.pure[Attempt]
              case _: NonTerminal.NT =>
                s170.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s166 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            166,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      s166.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s166) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`|` =>
                      (
                        s98,
                        (tok.left, s166) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.AnonList6Tail =>
                s124.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s167 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            167,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s168 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            168,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      (
                        s40,
                        (tok.left, s168) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s168.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s168) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.nonTerminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s168.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s168) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s168.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s168) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.listType =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s168.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s168) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s168.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s168) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.terminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s168.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s168) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s168.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s168) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.`Opt_?` =>
                s300.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s169 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            169,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s315,
                        (tok.left, s169) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s170 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            170,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      (
                        s117,
                        (tok.left, s170) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s171 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            171,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s172 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            172,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s173 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            173,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s180,
                        (tok.left, s173) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s174 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            174,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s216,
                        (tok.left, s174) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s184,
                        (tok.left, s174) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s152,
                        (tok.left, s174) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s256,
                        (tok.left, s174) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.NonOptElement =>
                s79.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s311.pure[Attempt]
              case _: NonTerminal.Raw =>
                s76.pure[Attempt]
              case _: NonTerminal.Element =>
                s73.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s175 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            175,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s222,
                        (tok.left, s175) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s16,
                        (tok.left, s175) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s6,
                        (tok.left, s175) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s289,
                        (tok.left, s175) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s175.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s175) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s292.pure[Attempt]
              case _: NonTerminal.Raw =>
                s106.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s166.pure[Attempt]
              case _: NonTerminal.Element =>
                s46.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s11.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s171.pure[Attempt]
              case _: NonTerminal.AnonList5Head =>
                s283.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s176 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            176,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s44,
                        (tok.left, s176) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s35,
                        (tok.left, s176) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      (
                        s294,
                        (tok.left, s176) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s17,
                        (tok.left, s176) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s272,
                        (tok.left, s176) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s176.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s176) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s155.pure[Attempt]
              case _: NonTerminal.Raw =>
                s156.pure[Attempt]
              case _: NonTerminal.Element =>
                s290.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s258.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s82.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s177 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            177,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      (
                        s313,
                        (tok.left, s177) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s178 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            178,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s179 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            179,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s8,
                        (tok.left, s179) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`)` =>
                      (
                        s26,
                        (tok.left, s179) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s180 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            180,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s181 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            181,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s32,
                        (tok.left, s181) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s111,
                        (tok.left, s181) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s277,
                        (tok.left, s181) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s298,
                        (tok.left, s181) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s181.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s181) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s228.pure[Attempt]
              case _: NonTerminal.Raw =>
                s270.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s215.pure[Attempt]
              case _: NonTerminal.Element =>
                s282.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s204.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s200.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s182 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            182,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      (
                        s314,
                        (tok.left, s182) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s182.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s182) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.listType =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s182.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s182) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s182.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s182) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`)` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s182.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s182) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s182.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s182) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.terminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s182.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s182) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s182.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s182) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.`Opt_?` =>
                s193.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s183 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            183,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s120,
                        (tok.left, s183) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s104,
                        (tok.left, s183) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s206,
                        (tok.left, s183) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s127,
                        (tok.left, s183) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.NonOptElement =>
                s74.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s188.pure[Attempt]
              case _: NonTerminal.Raw =>
                s172.pure[Attempt]
              case _: NonTerminal.Element =>
                s267.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s184 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            184,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s185 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            185,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s186 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            186,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s164,
                        (tok.left, s186) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s187 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            187,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s188 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            188,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s189 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            189,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s220,
                        (tok.left, s189) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`)` =>
                      (
                        s49,
                        (tok.left, s189) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s190 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            190,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s237,
                        (tok.left, s190) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s75,
                        (tok.left, s190) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s125,
                        (tok.left, s190) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s302,
                        (tok.left, s190) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s190.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s190) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s284.pure[Attempt]
              case _: NonTerminal.Raw =>
                s236.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s265.pure[Attempt]
              case _: NonTerminal.Element =>
                s308.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s182.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s241.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s191 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            191,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s192 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            192,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s193 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            193,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s194 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            194,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.AnonList8Tail._2
                      s194.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s194) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`|` =>
                      (
                        s31,
                        (tok.left, s194) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.AnonList8Tail =>
                s9.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s195 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            195,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s196 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            196,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s196.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s196) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`?` =>
                      (
                        s268,
                        (tok.left, s196) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s196.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s196) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.terminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s196.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s196) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.listType =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s196.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s196) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s196.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s196) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`)` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s196.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s196) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s196.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s196) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.`Opt_?` =>
                s262.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s197 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            197,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s198 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            198,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Char._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.escChar), poppedState)") :: Nil)
                      }
                    case tok: Tok.chars =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Char._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.escChar), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.escChar), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Char._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.escChar), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s199 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            199,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s200 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            200,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s201 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            201,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.AnonList6Tail._2
                      s201.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s201) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`|` =>
                      (
                        s98,
                        (tok.left, s201) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.AnonList6Tail =>
                s248.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s202 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            202,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s32,
                        (tok.left, s202) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s111,
                        (tok.left, s202) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s277,
                        (tok.left, s202) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s298,
                        (tok.left, s202) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s202.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s202) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s228.pure[Attempt]
              case _: NonTerminal.Raw =>
                s270.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s179.pure[Attempt]
              case _: NonTerminal.Element =>
                s282.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s204.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s200.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s203 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            203,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s105,
                        (tok.left, s203) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s204 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            204,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s204.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s204) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`?` =>
                      (
                        s71,
                        (tok.left, s204) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s204.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s204) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.listType =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s204.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s204) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s204.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s204) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`)` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s204.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s204) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s204.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s204) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.terminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s204.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s204) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s204.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s204) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.`Opt_?` =>
                s132.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s205 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            205,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s32,
                        (tok.left, s205) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s111,
                        (tok.left, s205) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s277,
                        (tok.left, s205) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s298,
                        (tok.left, s205) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s205.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s205) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s228.pure[Attempt]
              case _: NonTerminal.Raw =>
                s270.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s310.pure[Attempt]
              case _: NonTerminal.Element =>
                s282.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s204.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s200.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s206 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            206,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s198,
                        (tok.left, s206) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.chars =>
                      (
                        s138,
                        (tok.left, s206) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.Char =>
                s116.pure[Attempt]
              case _: NonTerminal.AnonList9Head =>
                s226.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s207 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            207,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s64,
                        (tok.left, s207) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s208 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            208,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s209 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            209,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s144,
                        (tok.left, s209) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s210 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            210,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ElementListSimple._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ElementListSimple._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s211 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            211,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s212 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            212,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  stack match {
                    case (Right(_3: NonTerminal.AnonList2Tail), _) :: (Left(_2: Tok.`;`), _) :: (Right(_1: NonTerminal.NT), poppedState) :: stack =>
                      val nt: NonTerminal = NonTerminal.AnonList2Tail._1(_1, _2, _3)
                      poppedState.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            None,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case _ =>
                      Dead(Marked("This should be impossible (1)... (Right(_3: NonTerminal.AnonList2Tail), _) :: (Left(_2: Tok.`;`), _) :: (Right(_1: NonTerminal.NT), poppedState)") :: Nil)
                  }
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s213 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            213,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s237,
                        (tok.left, s213) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s75,
                        (tok.left, s213) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s125,
                        (tok.left, s213) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s302,
                        (tok.left, s213) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s213.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s213) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s284.pure[Attempt]
              case _: NonTerminal.Raw =>
                s236.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s119.pure[Attempt]
              case _: NonTerminal.Element =>
                s308.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s182.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s241.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s214 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            214,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s208,
                        (tok.left, s214) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s215 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            215,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s252,
                        (tok.left, s215) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`)` =>
                      (
                        s47,
                        (tok.left, s215) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s216 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            216,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s32,
                        (tok.left, s216) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s111,
                        (tok.left, s216) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s277,
                        (tok.left, s216) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s298,
                        (tok.left, s216) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s216.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s216) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s228.pure[Attempt]
              case _: NonTerminal.Raw =>
                s270.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s139.pure[Attempt]
              case _: NonTerminal.Element =>
                s282.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s204.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s200.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s217 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            217,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s120,
                        (tok.left, s217) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s104,
                        (tok.left, s217) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s127,
                        (tok.left, s217) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s206,
                        (tok.left, s217) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s217.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s217) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s217.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s217) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s291.pure[Attempt]
              case _: NonTerminal.Raw =>
                s172.pure[Attempt]
              case _: NonTerminal.Element =>
                s45.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s74.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s188.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s218 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            218,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s219 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            219,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s220 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            220,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s237,
                        (tok.left, s220) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s75,
                        (tok.left, s220) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s125,
                        (tok.left, s220) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s302,
                        (tok.left, s220) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s220.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s220) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s284.pure[Attempt]
              case _: NonTerminal.Raw =>
                s236.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s123.pure[Attempt]
              case _: NonTerminal.Element =>
                s308.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s182.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s241.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s221 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            221,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_4: NonTerminal.ElementListSimple), _) :: (Right(_3: NonTerminal.Element), _) :: (Left(_2: Tok.`^`), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_4: NonTerminal.ElementListSimple), _) :: (Right(_3: NonTerminal.Element), _) :: (Left(_2: Tok.`^`), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_4: NonTerminal.ElementListSimple), _) :: (Right(_3: NonTerminal.Element), _) :: (Left(_2: Tok.`^`), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_4: NonTerminal.ElementListSimple), _) :: (Right(_3: NonTerminal.Element), _) :: (Left(_2: Tok.`^`), _) :: (Right(_1: NonTerminal.ElementListSimple), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s222 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            222,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s32,
                        (tok.left, s222) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s111,
                        (tok.left, s222) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s277,
                        (tok.left, s222) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s298,
                        (tok.left, s222) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s222.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s222) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s228.pure[Attempt]
              case _: NonTerminal.Raw =>
                s270.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s189.pure[Attempt]
              case _: NonTerminal.Element =>
                s282.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s204.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s200.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s223 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            223,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.nonTerminal =>
                      (
                        s141,
                        (tok.left, s223) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  val nt: NonTerminal = NonTerminal.AnonList2Tail._2
                  s223.onNt(nt) match {
                    case Alive(to) =>
                      (
                        to,
                        (nt.right, s223) :: stack,
                        None,
                      ).left.pure[Attempt]
                    case dead @ Dead(_) =>
                      dead
                  }
              }
            },
            {
              case _: NonTerminal.NT =>
                s297.pure[Attempt]
              case _: NonTerminal.AnonList2Tail =>
                s212.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s224 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            224,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s225 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            225,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      (
                        s91,
                        (tok.left, s225) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s226 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            226,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      (
                        s244,
                        (tok.left, s226) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s227 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            227,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s228 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            228,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`^` =>
                      (
                        s63,
                        (tok.left, s228) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s229 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            229,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s230 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            230,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      (
                        s251,
                        (tok.left, s230) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s231 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            231,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`@start:` =>
                      (
                        s88,
                        (tok.left, s231) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.Grammar =>
                s110.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s232 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            232,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s233 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            233,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s260,
                        (tok.left, s233) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s234 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            234,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.ListNT), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NTBody._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.ListNT), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s235 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            235,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s237,
                        (tok.left, s235) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s75,
                        (tok.left, s235) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s125,
                        (tok.left, s235) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s302,
                        (tok.left, s235) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s235.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s235) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s284.pure[Attempt]
              case _: NonTerminal.Raw =>
                s236.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s153.pure[Attempt]
              case _: NonTerminal.Element =>
                s308.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s182.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s241.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s236 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            236,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s237 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            237,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s32,
                        (tok.left, s237) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s111,
                        (tok.left, s237) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s277,
                        (tok.left, s237) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s298,
                        (tok.left, s237) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s237.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s237) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s228.pure[Attempt]
              case _: NonTerminal.Raw =>
                s270.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s296.pure[Attempt]
              case _: NonTerminal.Element =>
                s282.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s204.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s200.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s238 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            238,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s299,
                        (tok.left, s238) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s239 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            239,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s240 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            240,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s214,
                        (tok.left, s240) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s241 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            241,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s242 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            242,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s243 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            243,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s235,
                        (tok.left, s243) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`)` =>
                      (
                        s130,
                        (tok.left, s243) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s244 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            244,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s245 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            245,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s246 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            246,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s198,
                        (tok.left, s246) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.chars =>
                      (
                        s138,
                        (tok.left, s246) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.Char =>
                s116.pure[Attempt]
              case _: NonTerminal.AnonList9Head =>
                s18.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s247 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            247,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.nonTerminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.nonTerminal), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s248 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            248,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_3: NonTerminal.AnonList6Tail), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`|`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList6Tail._1(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_3: NonTerminal.AnonList6Tail), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`|`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s249 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            249,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s250 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            250,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.nonTerminal =>
                      (
                        s93,
                        (tok.left, s250) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s218,
                        (tok.left, s250) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.listType =>
                      (
                        s167,
                        (tok.left, s250) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s133,
                        (tok.left, s250) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`)` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s250.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s250) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`(` =>
                      (
                        s181,
                        (tok.left, s250) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s121.pure[Attempt]
              case _: NonTerminal.Raw =>
                s68.pure[Attempt]
              case _: NonTerminal.Element =>
                s143.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s50.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s54.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s251 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            251,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s252 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            252,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s237,
                        (tok.left, s252) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s75,
                        (tok.left, s252) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s125,
                        (tok.left, s252) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s302,
                        (tok.left, s252) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s252.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s252) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s284.pure[Attempt]
              case _: NonTerminal.Raw =>
                s236.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s19.pure[Attempt]
              case _: NonTerminal.Element =>
                s308.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s182.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s241.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s253 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            253,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s254 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            254,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s255 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            255,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s256 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            256,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s257 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            257,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s237,
                        (tok.left, s257) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s75,
                        (tok.left, s257) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s125,
                        (tok.left, s257) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s302,
                        (tok.left, s257) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s257.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s257) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s284.pure[Attempt]
              case _: NonTerminal.Raw =>
                s236.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s169.pure[Attempt]
              case _: NonTerminal.Element =>
                s308.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s182.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s241.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s258 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            258,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      (
                        s229,
                        (tok.left, s258) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s258.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s258) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.nonTerminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s258.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s258) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.listType =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s258.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s258) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s258.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s258) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.terminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s258.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s258) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s258.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s258) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.`Opt_?` =>
                s159.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s259 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            259,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s260 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            260,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s261 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            261,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s262 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            262,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s263 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            263,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList10Tail), _) :: (Right(_1: NonTerminal.Char), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList9Head(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.AnonList10Tail), _) :: (Right(_1: NonTerminal.Char), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s264 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            264,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s264.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s264) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`(` =>
                      (
                        s53,
                        (tok.left, s264) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s245,
                        (tok.left, s264) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s109,
                        (tok.left, s264) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s264.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s264) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.listType =>
                      (
                        s199,
                        (tok.left, s264) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s34,
                        (tok.left, s264) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s221.pure[Attempt]
              case _: NonTerminal.Raw =>
                s113.pure[Attempt]
              case _: NonTerminal.Element =>
                s84.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s23.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s154.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s265 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            265,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s274,
                        (tok.left, s265) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s266 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            266,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s267 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            267,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s120,
                        (tok.left, s267) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s104,
                        (tok.left, s267) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s127,
                        (tok.left, s267) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.listType =>
                      (
                        s146,
                        (tok.left, s267) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s206,
                        (tok.left, s267) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s267.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s267) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`|` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s267.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s267) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s100.pure[Attempt]
              case _: NonTerminal.Raw =>
                s172.pure[Attempt]
              case _: NonTerminal.Element =>
                s45.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s74.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s188.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s268 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            268,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s269 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            269,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s269.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s269) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.nonTerminal =>
                      (
                        s191,
                        (tok.left, s269) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s140,
                        (tok.left, s269) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.listType =>
                      (
                        s107,
                        (tok.left, s269) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s131,
                        (tok.left, s269) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`)` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s269.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s269) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`(` =>
                      (
                        s202,
                        (tok.left, s269) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s210.pure[Attempt]
              case _: NonTerminal.Raw =>
                s253.pure[Attempt]
              case _: NonTerminal.Element =>
                s269.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s196.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s129.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s270 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            270,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_1: NonTerminal.Raw), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Raw), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s271 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            271,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s272 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            272,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s273 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            273,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  stack match {
                    case (Right(_3: NonTerminal.AnonList1Head), _) :: (Left(_2: Tok.mode), _) :: (Left(_1: Tok.`@start:`), poppedState) :: stack =>
                      val nt: NonTerminal = NonTerminal.Grammar(_1, _2, _3)
                      poppedState.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, poppedState) :: stack,
                            None,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case _ =>
                      Dead(Marked("This should be impossible (1)... (Right(_3: NonTerminal.AnonList1Head), _) :: (Left(_2: Tok.mode), _) :: (Left(_1: Tok.`@start:`), poppedState)") :: Nil)
                  }
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s274 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            274,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s197,
                        (tok.left, s274) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s275 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            275,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s276 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            276,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s147,
                        (tok.left, s276) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s277 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            277,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s198,
                        (tok.left, s277) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.chars =>
                      (
                        s138,
                        (tok.left, s277) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.Char =>
                s116.pure[Attempt]
              case _: NonTerminal.AnonList9Head =>
                s177.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s278 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            278,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList7Head), _) :: (Left(_1: Tok.tilde), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AssocNT(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.AnonList7Head), _) :: (Left(_1: Tok.tilde), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s279 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            279,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`^` =>
                      (
                        s55,
                        (tok.left, s279) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s280 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            280,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      (
                        s307,
                        (tok.left, s280) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s281 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            281,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s237,
                        (tok.left, s281) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s75,
                        (tok.left, s281) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s125,
                        (tok.left, s281) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s302,
                        (tok.left, s281) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s281.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s281) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s284.pure[Attempt]
              case _: NonTerminal.Raw =>
                s236.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s114.pure[Attempt]
              case _: NonTerminal.Element =>
                s308.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s182.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s241.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s282 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            282,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      (
                        s35,
                        (tok.left, s282) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.listType =>
                      (
                        s10,
                        (tok.left, s282) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s17,
                        (tok.left, s282) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      (
                        s44,
                        (tok.left, s282) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s272,
                        (tok.left, s282) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s282.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s282) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s155.pure[Attempt]
              case _: NonTerminal.Raw =>
                s156.pure[Attempt]
              case _: NonTerminal.Element =>
                s290.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s258.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s82.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s283 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            283,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.AnonList5Head), _) :: (Left(_1: Tok.`^`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.LiftNT(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.AnonList5Head), _) :: (Left(_1: Tok.`^`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s284 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            284,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`^` =>
                      (
                        s25,
                        (tok.left, s284) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s285 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            285,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`\"` =>
                      (
                        s259,
                        (tok.left, s285) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s286 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            286,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.AssocNT), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NTBody._3(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AssocNT), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s287 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            287,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.AnonList8Tail._2
                      s287.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s287) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`|` =>
                      (
                        s31,
                        (tok.left, s287) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.AnonList8Tail =>
                s30.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s288 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            288,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      (
                        s89,
                        (tok.left, s288) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s289 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            289,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s290 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            290,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s44,
                        (tok.left, s290) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s35,
                        (tok.left, s290) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.listType =>
                      (
                        s87,
                        (tok.left, s290) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s17,
                        (tok.left, s290) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s272,
                        (tok.left, s290) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s290.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s290) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s155.pure[Attempt]
              case _: NonTerminal.Raw =>
                s156.pure[Attempt]
              case _: NonTerminal.Element =>
                s290.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s258.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s82.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s291 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            291,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.AnonList4Tail._2
                      s291.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s291) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`|` =>
                      (
                        s217,
                        (tok.left, s291) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.AnonList4Tail =>
                s57.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s292 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            292,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`^` =>
                      (
                        s183,
                        (tok.left, s292) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s293 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            293,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s61,
                        (tok.left, s293) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s294 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            294,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_2: Tok.listType), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s295 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            295,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s237,
                        (tok.left, s295) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s75,
                        (tok.left, s295) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s125,
                        (tok.left, s295) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s302,
                        (tok.left, s295) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s295.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s295) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s284.pure[Attempt]
              case _: NonTerminal.Raw =>
                s236.pure[Attempt]
              case _: NonTerminal.UnIgnoredElementList =>
                s149.pure[Attempt]
              case _: NonTerminal.Element =>
                s308.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s182.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s241.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s296 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            296,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s281,
                        (tok.left, s296) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`)` =>
                      (
                        s276,
                        (tok.left, s296) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s297 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            297,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      (
                        s223,
                        (tok.left, s297) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s298 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            298,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s299 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            299,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._3(_1, _2, _3, _4, _5, _6)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_6: Tok.listType), _) :: (Left(_5: Tok.`)`), _) :: (Right(_4: NonTerminal.UnIgnoredElementList), _) :: (Left(_3: Tok.`.`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s300 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            300,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Element(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.`Opt_?`), _) :: (Right(_1: NonTerminal.NonOptElement), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s301 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            301,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      (
                        s83,
                        (tok.left, s301) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.nonTerminal =>
                      (
                        s247,
                        (tok.left, s301) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s56,
                        (tok.left, s301) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s301.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s301) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.listType =>
                      (
                        s187,
                        (tok.left, s301) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s246,
                        (tok.left, s301) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s42.pure[Attempt]
              case _: NonTerminal.Raw =>
                s242.pure[Attempt]
              case _: NonTerminal.Element =>
                s60.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s304.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s22.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s302 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            302,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.terminal), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._2(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.terminal), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s303 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            303,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s51,
                        (tok.left, s303) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.listType), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ListNT._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.listType), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s304 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            304,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      (
                        s305,
                        (tok.left, s304) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`(` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s304.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s304) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.nonTerminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s304.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s304) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.terminal =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s304.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s304) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`;` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s304.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s304) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.listType =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s304.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s304) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok: Tok.`\"` =>
                      val nt: NonTerminal = NonTerminal.`Opt_?`._2
                      s304.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s304) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.`Opt_?` =>
                s0.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s305 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            305,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`;` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s306 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            306,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.ElementListSimple._1(_1, _2)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_2: NonTerminal.ElementListSimple), _) :: (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s307 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            307,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s308 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            308,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.nonTerminal =>
                      (
                        s35,
                        (tok.left, s308) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.listType =>
                      (
                        s158,
                        (tok.left, s308) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`\"` =>
                      (
                        s17,
                        (tok.left, s308) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`)` =>
                      stack match {
                        case (Right(_1: NonTerminal.Element), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.UnIgnoredElementList._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.Element), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      (
                        s44,
                        (tok.left, s308) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.terminal =>
                      (
                        s272,
                        (tok.left, s308) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`^` =>
                      val nt: NonTerminal = NonTerminal.ElementListSimple._2
                      s308.onNt(nt) match {
                        case Alive(to) =>
                          (
                            to,
                            (nt.right, s308) :: stack,
                            tokens.some,
                          ).left.pure[Attempt]
                        case dead @ Dead(_) =>
                          dead
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.ElementListSimple =>
                s155.pure[Attempt]
              case _: NonTerminal.Raw =>
                s156.pure[Attempt]
              case _: NonTerminal.Element =>
                s290.pure[Attempt]
              case _: NonTerminal.NonOptElement =>
                s258.pure[Attempt]
              case _: NonTerminal.AnonList =>
                s82.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s309 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            309,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.AnonList._2(_1, _2, _3, _4)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_4: Tok.listType), _) :: (Left(_3: Tok.`)`), _) :: (Right(_2: NonTerminal.UnIgnoredElementList), _) :: (Left(_1: Tok.`(`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s310 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            310,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      (
                        s295,
                        (tok.left, s310) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.`)` =>
                      (
                        s59,
                        (tok.left, s310) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s311 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            311,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`;` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.`|` =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Right(_1: NonTerminal.AnonList), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.NonOptElement._4(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Right(_1: NonTerminal.AnonList), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s312 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            312,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.escChar =>
                      (
                        s198,
                        (tok.left, s312) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok: Tok.chars =>
                      (
                        s138,
                        (tok.left, s312) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _: NonTerminal.Char =>
                s116.pure[Attempt]
              case _: NonTerminal.AnonList9Head =>
                s29.pure[Attempt]
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s313 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            313,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.`.` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`?` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.Raw(_1, _2, _3)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_3: Tok.`\"`), _) :: (Right(_2: NonTerminal.AnonList9Head), _) :: (Left(_1: Tok.`\"`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s314 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            314,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.nonTerminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.listType =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`\"` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`)` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`(` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.terminal =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok: Tok.`^` =>
                      stack match {
                        case (Left(_1: Tok.`?`), poppedState) :: stack =>
                          val nt: NonTerminal = NonTerminal.`Opt_?`._1(_1)
                          poppedState.onNt(nt) match {
                            case Alive(to) =>
                              (
                                to,
                                (nt.right, poppedState) :: stack,
                                tokens.some,
                              ).left.pure[Attempt]
                            case dead @ Dead(_) =>
                              dead
                          }
                        case _ =>
                          Dead(Marked("This should be impossible (1)... (Left(_1: Tok.`?`), poppedState)") :: Nil)
                      }
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s315 =
          Grammar.State[Tok, NonTerminal, NtRoot](
            315,
            { (stack, tokens) =>
              tokens match {
                case Some(tokens) =>
                  tokens.head match {
                    case tok: Tok.listType =>
                      (
                        s7,
                        (tok.left, s315) :: stack,
                        tokens.tail.toNel,
                      ).left.pure[Attempt]
                    case tok =>
                      Dead(Marked("Unexpected token", tok.span.some) :: Nil)
                  }
                case None =>
                  Dead(Marked("Unexpected EOF") :: Nil)
              }
            },
            {
              case _ =>
                Dead(Marked("This should be impossible (3)...") :: Nil)
            },
          )
        
        s231
      },
    )
  
}
// format: on
